[{"title":"SQL窗口函数的使用","url":"/2025/06/17/SQL%E7%AA%97%E5%8F%A3%E5%87%BD%E6%95%B0/","content":"这篇文章着重于理解数据库中使用窗口函数进行高级SQL语句的编写方法，并加以使用。\n窗口函数相较于普通SQL，有什么不同？简单来说，窗口函数有以下功能：\n1、同时具有分组和排序的功能\n2、不减少原表的行数\n\n  \n    \n      运用场景举例\n\n    \n    \n      排名问题：每个部门按业绩来排名\ntopN问题：找出每个部门排名前N的员工进行奖励\n复购分析：App内要分析复购用户有多少\n累计问题：医院要经常统计累计患者数\n\n    \n  \n这类在每组内排名场景使用普通SQL语句很复杂，不易实现，这个时候就需要窗口函数简化查询语句的编写。\n窗口函数的基本使用窗口函数的基本语法如下：\n&lt;窗口函数&gt; over (partition by &lt;用于分组的列名&gt; order by &lt;用于排序的列名&gt;)\n\n那么语法中的窗口函数都有哪些呢？\n窗口函数的位置，可以放以下两种函数：\n1、专用窗口函数，包括rank, dense_rank, row_number等专用窗口函数。\n2、聚合函数，如sum. avg, count, max, min等。\n因为窗口函数是对where或者group by子句处理后的结果进行操作，所以窗口函数原则上只能写在select子句中。\n专用窗口函数rank以一个班级表举例：\n想在每个班级内按成绩排名，得到下面的结果。\n\n得到上面结果的sql语句代码如下:\nselect *,   rank() over (partition by 班级                 order by 成绩 desc) as rankingfrom 班级表\npartition by用来对表分组,order by子句的功能是对分组后的结果进行排序。\n窗口函数具备了group by子句分组的功能和order by子句排序的功能。那么为什么还要用窗口函数呢？\n因为，group by分组汇总后改变了表的行数，一行只有一个类别。而partiition by和rank函数不会减少原表中的行数。\n其他专用窗口函数rank, dense_rank, row_number有什么区别呢？举个例子：\nselect *,   rank() over (order by 成绩 desc) as ranking,   dense_rank() over (order by 成绩 desc) as dese_rank,   row_number() over (order by 成绩 desc) as row_numfrom 班级表\n上述代码得到结果如图：\n\n从上面的结果可以看出：\n\n  \n    \n      专用函数区别\n\n    \n    \n      rank函数：这个例子中是5位，5位，5位，8位，也就是如果有并列名次的行，会占用下一名次的位置。比如正常排名是1，2，3，4，但是现在前3名是并列的名次，结果是：1，1，1，4。\ndense_rank函数：这个例子中是5位，5位，5位，6位，也就是如果有并列名次的行，不占用下一名次的位置。比如正常排名是1，2，3，4，但是现在前3名是并列的名次，结果是：1，1，1，2。\nrow_number函数：这个例子中是5位，6位，7位，8位，也就是不考虑并列名次的情况。比如前3名是并列的名次，排名是正常的1，2，3，4。\n\n    \n  \n\n可以用一张图解释：\n\n聚合函数作为窗口函数select *,   sum(成绩) over (order by 学号) as current_sum,   avg(成绩) over (order by 学号) as current_avg,   count(成绩) over (order by 学号) as current_count,   max(成绩) over (order by 学号) as current_max,   min(成绩) over (order by 学号) as current_minfrom 班级表\n看一下结果：\n如上图，聚合函数sum在窗口函数中，是对自身记录、及位于自身记录以上的数据进行求和的结果。比如0004号，在使用sum窗口函数后的结果，是对0001，0002，0003，0004号的成绩求和，若是0005号，则结果是0001号~0005号成绩的求和，以此类推。\n不仅是sum求和，平均、计数、最大最小值，也是同理，都是针对自身记录、以及自身记录之上的所有数据进行计算。\n这样使用窗口函数有什么用呢？聚合函数作为窗口函数，可以在每一行的数据里直观的看到，截止到本行数据，统计数据是多少（最大值、最小值等）。同时可以看出每一行数据，对整体统计数据的影响。\n注意：partition子句可是省略，省略就是不指定分组。但是，这就失去了窗口函数的功能，所以一般不这么使用。\n一个练习具体例子1.获取每个部门中薪水最高的员工相关信息\n参考答案 \n              \n              WITH mix AS (    SELECT d.dept_no, d.emp_no, s.salary    FROM dept_emp d    JOIN salaries s ON d.emp_no = s.emp_no),rank_table AS (    SELECT *,           RANK() OVER (PARTITION BY dept_no ORDER BY salary DESC) AS salary_rank    FROM mix)SELECT dept_no, emp_no, salaryFROM rank_tableWHERE salary_rank = 1;\n              \n            \n\n参考来源: 知乎：通俗易懂的学会SQL窗口函数\n","categories":["关系型数据库"],"tags":["SQL编写"]},{"title":"手写Spring框架Day2","url":"/2025/10/02/%E6%89%8B%E5%86%99Spring%E6%A1%86%E6%9E%B6Day2/","content":"进入第二天了，今天要学的东西就比较深入一些了。\n第一部分 依赖注入在昨天我们已经实现了bean的创建和管理。既然创建了bean，那就需要使用，也就是当一个bean要使用到别的bean，就得把这个bean给他放入需要bean的类中吧。\n怎么实现呢？首先肯定想到怎么标识需要注入的地方，用过Spring的都知道有一个@Autowired注解。那我们就把他创建出来。\n@Retention(RetentionPolicy.RUNTIME)@Target(ElementType.FIELD)public @interface Autowired &#123;    String value() default &quot;&quot;;&#125;\n我们再创建一个新的OrderService，把他也注册成bean。然后，在原先的UserService中去注入这个OrderService的bean。\n@Componentpublic class OrderService &#123;&#125;@Componentpublic class UserService &#123;    @Autowired    private OrderService orderService;    public void  test()&#123;        System.out.println(orderService);    &#125;&#125;\n好了，现在标识已经做好了。那不能只有表面功夫吧，加个注解就完事；肯定要为他去实现一个依赖注入的功能。要在哪里实现呢？\n想想昨天写过的东西，构造函数？似乎只是用来扫描和把创建出来的bean加入单例池；getBean？更不对了，只是用来获取bean的，都不知道要注入到哪里……\n对了！createBean可太适合不过了！在昨天的代码里，这里面可是把每一个bean进行实例化的地方，那实例化之后，跟着把里面的内容一起给他放进去，不是妙哉？\n所以，我们先获取实例化的实例所有内部字段，再一个个遍历判断是否有加上注解，如果加上了@Autowired，那就进行注入就好了。\n那怎么注入呢？首先需要拿到注入的bean实例，getBean方法就有用了，把字段的名字传给getBean，这样就拿到了需要注入的一个实例，我们写好的getBean会帮我们解决单多例的问题。然后就可以通过反射把这个bean注入了。\nprivate Object createBean(String beanName, BeanDefinition beanDefinition) &#123;    Class clazz = beanDefinition.getType();    try &#123;        Object instance = clazz.getConstructor().newInstance();        //依赖注入        for (Field field : clazz.getDeclaredFields()) &#123;            if(field.isAnnotationPresent(Autowired.class))&#123;                //允许修改                field.setAccessible(true);                //将这个bean实例注入需要注入的实例里                field.set(instance,getBean(field.getName()));            &#125;        &#125;        return instance;    &#125; catch (InstantiationException e) &#123;        throw new RuntimeException(e);    &#125; catch (IllegalAccessException e) &#123;        throw new RuntimeException(e);    &#125; catch (InvocationTargetException e) &#123;        throw new RuntimeException(e);    &#125; catch (NoSuchMethodException e) &#123;        throw new RuntimeException(e);    &#125;&#125;\n这样我们就实现bean的DI了！用测试方法看看bean的打印情况：\npublic class Test &#123;    public static void main(String[] args) &#123;        SwissApplicationContext swissApplicationContext = new SwissApplicationContext(AppConfig.class);        UserService userService = (UserService) swissApplicationContext.getBean(&quot;userService&quot;);        userService.test();    &#125;&#125;\ncom.swiss.service.OrderService@6f94fa3e\n依赖注入就实现了。\n第二部分 Aware回调在有的时候，我们在bean实例化和依赖注入后，想要得到一些注册出的bean内容，比如我并不知道bean名字在Spring容器中的默认命名规则，但我想要知道当前这个bean在IOC中以什么名字存储，这个时候就需要一个回调，我们可以根据这个回调，拿到bean的一些有关信息，这就是Aware回调。\n这里我们模拟一个bean名字获取的回调，创建回调接口：\npublic interface BeanNameAware &#123;    void setBeanName(String beanName);&#125;\n然后我们就可以去实现这个接口，得到beanName。注意，这个回调函数是在Spring中自动被调用的，也就是Spring会自动把bean名字传进来。\n@Componentpublic class UserService implements BeanNameAware &#123;    @Autowired    private OrderService orderService;    private String beanName;    @Override    public void setBeanName(String beanName) &#123;        this.beanName = beanName;    &#125;    public void test()&#123;        System.out.println(orderService);    &#125;&#125;\n这样我们通过beanName的Aware回调，拿到了想要的bean的名字。\n当然实际上还有好多回调：BeanClassLoaderAware，BeanFactoryAware，ApplicationContextAware……但是都和这个原理相同。\n第三部分 初始化回调在bean处理好了之后，我们想要对其进行一些预先的操作，比如给一些东西赋值啊之类的，这个时候就是属于初始化的内容了。\nSpring为初始化回调提供了一个接口，和上面的Aware一样，我们需要自己去实现，然后进行自己想要的操作。注意，这里面你想做什么，Spring都不会管，也不会传来任何参数，完全是你自己的逻辑。\npublic interface InitializingBean &#123;    void afterPropertiesSet();&#125;@Componentpublic class UserService implements BeanNameAware, InitializingBean &#123;    @Autowired    private OrderService orderService;    private String beanName;    private String INeed;    @Override    public void setBeanName(String beanName) &#123;        this.beanName = beanName;    &#125;    @Override    public void afterPropertiesSet() &#123;        //很多很多想要在初始化执行的都可以写在这里        this.INeed =  &quot;Mika&quot;;    &#125;    public void  test()&#123;        System.out.println(orderService);    &#125;&#125;\n比如在这里，我为我的一个成员变量赋了一个值，我还可以输出，存储……干什么都可以。这就是初始化的回调作用。\n第四部分 BeanPostProcessor Bean的后置处理器为了更好、更灵活的管理bean对象，Spring还在初始化的前后提供了处理的方法。BeanPostProcessor接口就是用来让插入在初始化前后的一些想要执行的逻辑。\npublic interface BeanPostProcessor &#123;    void postProcessBeforeInitialization(String beanName, Object bean);    void postProcessAfterInitialization(String beanName, Object bean);&#125;\n这两个方法分别在初始化前、后调用。\n我们可以试着实现以下这两个方法：\n@Componentpublic class SwissBeanPostProcessor implements BeanPostProcessor &#123;    @Override    public void postProcessBeforeInitialization(String beanName, Object bean) &#123;        if(beanName.equals(&quot;userService&quot;))&#123;            System.out.println(&quot;1111&quot;);        &#125;    &#125;    @Override    public void postProcessAfterInitialization(String beanName, Object bean) &#123;        if(beanName.equals(&quot;userService&quot;))&#123;            System.out.println(&quot;2222&quot;);        &#125;    &#125;&#125;\n我们实现的逻辑是：bean的名字是userService的时候，在初始化前打印一个1111，在初始化后打印一个2222。\n这些调用在我们写好逻辑后，Spring会帮我们自动在初始化前后调用。那Spring是怎么知道有哪些后置处理器的？\n这个需要在Spring里面进行处理。在注册完所有BeanDefinition后，专门处理BeanPostProcessor的创建，使其被初始化成一个成熟的bean，然后加入List进行管理。\n在处理其他正常bean的时候，遇到BeanPostProcessor子类就跳过即可。\n\n  \n    \n      提示！\n\n    \n    \n      但是！这里为了简单方便，我们在构造函数里面扫描的时候就直接创建BeanPostProcessor实例！实际上不应该是这样,会导致这样创建出来的实例没有被DI，是个残缺的bean，所以下面这一段代码仅供参考。\n\n    \n  \nif (clazz.isAnnotationPresent(Component.class)) &#123;    //说明这是一个bean，开始创建beanDefinition对象    //先把BeanPostProcessor的实现子类存起来    if (BeanPostProcessor.class.isAssignableFrom(clazz)) &#123;    BeanPostProcessor instance = (BeanPostProcessor) clazz.newInstance();    beanPostProcessorList.add(instance);&#125;……\n然后，在初始化前后，遍历bean后置处理器的List，执行定义的方法即可。\nfor (BeanPostProcessor beanPostProcessor : beanPostProcessorList) &#123;    instance = beanPostProcessor.postProcessBeforeInitialization(beanName,instance);&#125;//初始化if (instance instanceof InitializingBean) &#123;    ((InitializingBean) instance).afterPropertiesSet();&#125;for (BeanPostProcessor beanPostProcessor : beanPostProcessorList) &#123;    instance = beanPostProcessor.postProcessAfterInitialization(beanName,instance);&#125;\n我们试着运行一下：\n1111Mika（afterPropertiesSet，初始化方法打印）2222\n确实是在初始化的前后插入了逻辑。\n这就是bean的后置处理器BeanPostProcessor。在Spring里面实现了很多BeanPostProcessor，如下面的AOP。当然我们也可以自己实现BeanPostProcessor，执行想要的逻辑。\n第五部分 AOP在上一个部分中，讲到了Bean的后置处理器，可以在Bean被初始化的前后执行一些逻辑。\n但我们知道，我们有时候可能对于某个bean需要增强，如AOP的切面。这个时候，我们就需要代理对象来实现增强的内容，而不是原生的bean实例。\n在Spring中，有一个AnnotationAwareAspectJAutoProxyCreator，会解析@Aspect里面的内容，根据匹配的切点表达式得到是哪个bean，然后进行动态代理创建，构造一个拦截器链，按顺序执行前置通知、目标方法、后置通知等等。但我们这里同样是一个模拟，简单的处理。\n首先我们需要把上一部分的postProcessBeforeInitialization和postProcessAfterInitialization返回值改为Object。因为需要返回一个代理对象了。\n然后在postProcessAfterInitialization里面，也就是初始化完成后，我们将进行动态代理的创建。这里为userService增强，创建一个JDK动态代理，首先需要创建一个interface（JDK只支持接口代理）：\npublic interface UserInterface &#123;    void test();&#125;\n然后我们让UserService去实现这个接口，就可以为UserService创建动态代理了。\n@Overridepublic Object postProcessAfterInitialization(String beanName, Object bean) &#123;    if (beanName.equals(&quot;userService&quot;)) &#123;        return Proxy.newProxyInstance(SwissApplicationContext.class.getClassLoader(), bean.getClass().getInterfaces(), new InvocationHandler() &#123;            @Override            public Object invoke(Object proxy, Method method, Object[] args) throws Throwable &#123;                System.out.println(&quot;切面逻辑&quot;);                return method.invoke(bean, args);            &#125;        &#125;);    &#125;    return bean;&#125;\n可以看到，这里userService的bean已经将变成代理对象返回。那我们尝试使用getBean得到的bean去进行原先的test方法：\n切面逻辑com.swiss.service.OrderService@355da254\n成功了！增强逻辑被实现了，也就是我们的AOP动态代理增强实现了。\n第二天的学习内容结束了！\n","categories":["Spring"],"tags":["底层原理"]},{"title":"手写Spring框架Day1","url":"/2025/10/01/%E6%89%8B%E5%86%99Spring%E6%A1%86%E6%9E%B6day1/","content":"开始探究Spring啦！先从最简单最原理的部分写起。\n第一步 创建Spring容器日常使用的有根据路径拿到配置的容器类（ClassPathXmlApplicationContext），也有根据java配置类拿到配置的容器类（AnnotationConfigApplicationContext）。今天手写的是根据配置的Spring容器。创建容器类SwissApplicationContext。里面先写上一个成员变量，也就是指定的配置类：\nprivate Class configClass;\n创建一个类用来当作配置类，命名为AppConfig。配置类嘛，肯定有个配置类的注解，标志一下扫描的路径，也就是@ComponentScan。写出这个注解，加到配置类的头上：\n@ComponentScan(&quot;com.swiss.service&quot;)public class AppConfig &#123;&#125;\n然后我们创建一个用来当作bean的类UserService。当然，要注册成bean，最简单的一个注解就是@Component了。同样创建出来加到UserService头上。这两个注解目前都只有一个默认的value属性，一个定义扫描路径，一个定义bean的名字。现在可以回到容器SwissApplicationContext上了。容器容器，肯定是要拿bean的嘛，所以肯定有一个getBean方法。所以创建一个暂时返回null的getBean，后续补充。\npublic Object getBean(String beanName) &#123;    return null;&#125;\n新建Test类，把容器new出来。\nSwissApplicationContext swissApplicationContext = new SwissApplicationContext(AppConfig.class);\n然后写一个getBean：\nUserService userService = (UserService) swissApplicationContext.getBean(&quot;userService&quot;);\n当然这个getBean只是一个暂时的。毕竟bean的类型还需要确定嘛。到这里，前置的Spring容器创建准备就做好了。\n第二步 开始扫描我们知道，在容器创建的时候，就要开始进行bean的创建了。那么第一步肯定是发现bean吧，所以肯定在构造函数里面开始进行扫描。这个时候就用到了配置类：配置类的顶着@ComponentScan注解，告诉Spring容器应该在哪里去扫描bean，就像上面写的一样：\n@ComponentScan(&quot;com.swiss.service&quot;)\n所以首先就得获得这个配置类告诉我们的包路径了。容器里面已经有一个配置类的成员变量实例了，直接拿来用：\nif (configClass.isAnnotationPresent(ComponentScan.class)) &#123;&#125;\n存在ComponentScan注解，再获取扫描包路径：\nComponentScan componentScanAnnotation = (ComponentScan) configClass.getAnnotation(ComponentScan.class);String path = componentScanAnnotation.value(); //获得扫描路径 com.swiss.service\n但是现在就有一个问题了：扫描的内容应该是编译出来的class文件，因为运行时环境只加载.class文件，并且Spring依赖Java反射机制，所以这个路径需要做一些处理才能得到真正的编译出class文件的路径。\nstep1：把路径里面的”.”改为”&#x2F;“。path = path.replace(&quot;.&quot;, &quot;/&quot;);//com/swiss/service\nstep2：（最重要）通过类加载器得到class资源存放路径，因为JVM会通过类路径（classpath）来查找.class文件和资源文件。ClassLoader classLoader = SwissApplicationContext.class.getClassLoader();URL resource = classLoader.getResource(path);\n如果路径中有空格等非全英文路径情况，记得URL解析一下：\nString decodedPath;try &#123;    decodedPath = URLDecoder.decode(resource.getFile(), String.valueOf(StandardCharsets.UTF_8));&#125; catch (UnsupportedEncodingException e) &#123;    System.out.println(&quot;URL错误！&quot;);    return;&#125;\n如果没有的话，直接File file &#x3D; new File(resource.getFile());即可，否则传入解析后的URL。这个时候存放class文件的File文件夹就被我们获取到了。我们可以遍历文件，判断哪些是.class文件，然后进一步处理。\nif (file.isDirectory()) &#123;    File[] list = file.listFiles();    for (File f : list) &#123;        String fileName = f.getAbsolutePath();        if (fileName.endsWith(&quot;.class&quot;)) &#123;                                &#125;    &#125;&#125;\n接着，如果是class文件，要怎么办呢？就得开始确定这个类是否为bean了吧。我们知道，bean是通过@Component注解指定的，所以我们只需要确定类上有没有这个注解。那又怎么拿到这个class对象呢？找找前面，我们发现有一个classloader已经被我们定义好了。那直接把这个类的全限定名丢进去load，不就得到这个class对象了吗？这个时候，我们就可以判断是否有注解声明啦。\ntry &#123;    //这边需要传入一个类的全限定名字，如com.swiss.service.UserService，这边为了省事，就写死，实际上应该要去完成一个灵活的路径拆分得到全限定名字    String className = fileName.substring(fileName.indexOf(&quot;com&quot;), fileName.indexOf(&quot;.class&quot;));    className = className.replace(&quot;\\\\&quot;, &quot;.&quot;);    System.out.println(className);    Class&lt;?&gt; clazz = classLoader.loadClass(className);    if (clazz.isAnnotationPresent(Component.class)) &#123;        //说明这是一个bean    &#125;&#125; catch (ClassNotFoundException e) &#123;    System.out.println(&quot;获取是否为bean时，加载类失败！&quot;);    return;&#125;\n扫描的原理也就到这里结束咯。\n第三步 BeanDefinition的生成在上一步中，我们判断到了某一个类是否为一个bean，那么接下来是不是应该要开始创建实例存储了呢？当然不急！虽然还没写之前还有所耳闻，Spring里面是单例bean；但是bean也是可以多例的。为了标识这个bean是否需要多例，需要一个@Scope注解。\n@Target(ElementType.TYPE)@Retention(RetentionPolicy.RUNTIME)public @interface Scope &#123;    String value() default &quot;&quot;;&#125;\n对于之前的UserService，我们加上这个注解：\n@Component@Scope(&quot;prototype&quot;)public class UserService &#123;&#125;\nprototype应该不陌生吧，就是多例。标记好了bean的单多例情况，接下来难道就要开始创建了吗？也不是，Spring在真正实例化bean的前面还加了一个态：BeanDefinition，方便处理单多例情况。那我们就着手写一个beanDefinition吧。也就是bean的定义。需要一些什么成员变量呢？首先肯定是类型。class类型对象，然后就是scope，也就是单多例情况。先写这两个吧。\npublic class BeanDefinition &#123;    private Class type;    private String scope;    public Class getType() &#123;        return type;    &#125;    public void setType(Class type) &#123;        this.type = type;    &#125;    public String getScope() &#123;        return scope;    &#125;    public void setScope(String scope) &#123;        this.scope = scope;    &#125;&#125;\n这下我们就可以回头继续完成构造方法了，当判断到一个类是bean的时候，我们先对其进行定义，通过解析@Scope确定单多例和@Component确定bean的名字（如果没有，默认使用类名）：\nString beanName = clazz.getAnnotation(Component.class).value();if (beanName.isEmpty()) &#123; //这边需要判断用户是否有指定bean名字，如果没有就应该使用默认规定变为驼峰，或者不变，如URLService就无需变化    beanName = Introspector.decapitalize(clazz.getSimpleName());&#125;BeanDefinition beanDefinition = new BeanDefinition();if (clazz.isAnnotationPresent(Scope.class)) &#123;    Scope scopeAnnotation = clazz.getAnnotation(Scope.class);    beanDefinition.setScope(scopeAnnotation.value());&#125; else &#123;    beanDefinition.setScope(&quot;singleton&quot;);&#125;beanDefinition.setType(clazz);\n构建好了，把这个定义存起来就行了。在容器里面新定义一个线程安全哈希表，并加入：\nprivate ConcurrentHashMap&lt;String, BeanDefinition&gt; beanDefinitionMap = new ConcurrentHashMap&lt;&gt;();beanDefinitionMap.put(beanName, beanDefinition);\n好了，beanDefinition的定义就构建出来了。\n第四步 完成getBean方法我们现在已经有了一个存着beanDefinition的Map了，我们会发现有一些bean已经是单例的，那我们是不是可以考虑直接进行创建进行管理呢？完全可以！继续在构造函数后面进行添加一些创建的内容。注意：这一步我们并没有具体实现创建bean的流程，而是实现getBean的自身逻辑。对于单例的bean，我们可以创建一个单例池来进行管理，然后我们直接在构造函数最后开始进行创建单例bean：\nprivate ConcurrentHashMap&lt;String, Object&gt; singletonObjects = new ConcurrentHashMap&lt;&gt;();for (String beanName : beanDefinitionMap.keySet()) &#123;    BeanDefinition beanDefinition = beanDefinitionMap.get(beanName);    if (beanDefinition.getScope().equals(&quot;singleton&quot;)) &#123;        Object bean = createBean(beanName, beanDefinition);//createBean方法将在后面进行完成        singletonObjects.put(beanName, bean);    &#125;&#125;\n这么一来，我们直接就有了单例的bean池。那getBean也就好说了：\npublic Object getBean(String beanName) &#123;    BeanDefinition beanDefinition = beanDefinitionMap.get(beanName);    if (beanDefinition == null) &#123;        throw new NullPointerException();    &#125; else &#123;        String scope = beanDefinition.getScope();        if (scope.equals(&quot;singleton&quot;)) &#123;            Object bean = singletonObjects.get(beanName);            if (bean == null) &#123;                bean = createBean(beanName, beanDefinition);                singletonObjects.put(beanName, bean);            &#125;            return bean;        &#125; else &#123;            //多例            return createBean(beanName,beanDefinition);        &#125;    &#125;&#125;\ngetBean就是如此简单！\n第五步 创建bean终于来到创建Bean的时候了。在上面遗留的createBean方法中，我们可以用反射轻松的实现实例化一个bean：\nprivate Object createBean(String beanName, BeanDefinition beanDefinition) &#123;    Class clazz = beanDefinition.getType();    try &#123;        Object instance = clazz.getConstructor().newInstance();        return instance;    &#125; catch (InstantiationException e) &#123;        throw new RuntimeException(e);    &#125; catch (IllegalAccessException e) &#123;        throw new RuntimeException(e);    &#125; catch (InvocationTargetException e) &#123;        throw new RuntimeException(e);    &#125; catch (NoSuchMethodException e) &#123;        throw new RuntimeException(e);    &#125;&#125;\n那么似乎到目前为之，一个可以使用的核心架构就出来了呢。在Test方法里面，我们开始测试：\npublic class Test &#123;    public static void main(String[] args) &#123;        SwissApplicationContext swissApplicationContext = new SwissApplicationContext(AppConfig.class);        System.out.println(swissApplicationContext.getBean(&quot;userService&quot;));        System.out.println(swissApplicationContext.getBean(&quot;userService&quot;));        System.out.println(swissApplicationContext.getBean(&quot;userService&quot;));        System.out.println(swissApplicationContext.getBean(&quot;userService&quot;));    &#125;&#125;    \n看输出结果：\ncom.swiss.service.UserService@60e53b93com.swiss.service.UserService@60e53b93com.swiss.service.UserService@60e53b93com.swiss.service.UserService@60e53b93\n果然是单例！那再把Scope换成prototype呢：\ncom.swiss.service.UserService@5e2de80ccom.swiss.service.UserService@1d44bcfacom.swiss.service.UserService@266474c2com.swiss.service.UserService@6f94fa3e\n是多例，成功了。 \n到这里，第一天的核心的内容也就结束了。\n","categories":["Spring"],"tags":["底层原理"]},{"title":"手写Spring框架Day3","url":"/2025/10/03/%E6%89%8B%E5%86%99Spring%E6%A1%86%E6%9E%B6day3/","content":"第三天就不写了，来细致的了解一些前两天没有写到的一些细节。\n现在我们可以知道，一个Bean创建的生命周期如下：\n\n  \n    \n      生命周期\n\n    \n    \n      UserService.class –&gt; 推断构造函数 –&gt; 对象（实例化） –&gt; 依赖注入 –&gt; 初始化前 –&gt; 初始化 –&gt; 初始化后（AOP） –&gt; 代理对象 –&gt; 放入Map单例池 –&gt; Bean对象\n\n    \n  \n有一些部分我们在简单手写模拟的时候没有仔细的进行探究，比如：\n推断构造函数使用过Spring，我们都知道，依赖注入不仅可以通过@Autowired等注解声明，还有构造函数注入。实际上，Spring更为推荐构造函数注入方式，我们经常看见@Autowired注解上会有淡淡的黄线提示推荐使用构造函数注入。那一个类里面的构造函数可能很多，Spring又是怎么知道该使用哪个构造函数呢？首先，在只有一个构造函数的前提下，肯定就直接使用那个构造函数。其次，如果构造函数超出一个，就要开始条件判断：\n是否有@Autowired注解声明的构造函数如果有，还要判断有几个构造函数被加上了@Autowired。如果只有一个，就用那个。超出一个，报错，因为Spring不知道要用哪个。如果没有，进入下一个判断。\n是否有无参构造函数如果有，直接调用无参构造。如果没有，也报错，因为Spring仍然不知道要用哪个构造函数。依据这样的规则，这样Spring就可以得到想要的唯一构造函数，然后调用。\n找到构造函数bean知道了要用哪个构造函数，那怎么去找到合适的bean注入到这个构造函数呢？\n首先有个概念需要理解：单例bean中的单例不是对于这个类来说的，而是对于这个bean名字来说的。即，即使类型一样，也可以存在多个bean；但是一个bean名字只有一个bean对象。\n我们可以通过一个代码来理解一下：\n@Componentpublic class UserService&#123;&#125;//APPConfig@beanpublic UserService userService1()&#123;    return new UserService;&#125;@beanpublic UserService userService2()&#123;    return new UserService;&#125;\n好了，这下类型居然有了三个bean，只是bean的名字不一样而已。\n那是不是根据bean名字去找就行了？\n看看这个例子：\npublic UserService(OrderService service)&#123;    this.OrderService = service;&#125;\n这里的bean名字，不是固定的。程序员完全可以乱命名，这样就会拿到一个一个乱七八糟的bean，根本注入不进去。\n所以，这里想要找到构造函数里面的bean，既不能只根据类型，也不能只根据bean名字。应该先根据类型找到所有bean，再根据bean名字确定具体bean实例。\n\n  \n    \n      注意\n\n    \n    \n      如果类型只有一个bean实例，那就直接用就好了。\n\n    \n  \n如果这样的方法无法确定，就只能报错了，说明程序员根本不想让Spring找到这个bean……\n那现在就有个疑问了，那这不是执行了DI依赖注入吗？那不是破坏了原本的生命周期顺序了吗？\n其实不是的，这里只是因为要实例化不得已必须将需要的依赖注入，其他暂时没有使用的依赖，即使标注了@Autowired，也是不会注入的，会等到后续的DI注入环节完成注入。\n现在我们可以分析一下为什么Spring强烈推荐构造函数注入了。\n1、在实例化完成后，这个bean就已经是一个完整可用的bean了。\n2、构造函数注入天然支持final字段。\n3、避免NullPointerException，构造函数注入的依赖缺失会在应用启动时立即报错，而不是等到运行时才抛出NullPointerException。\n一点小八股：你知道@Autowired和@Resource查找bean的顺序是怎么样的吗？\n@PostConstruct这个注解修饰的方法执行是在DI注入，Aware回调后，初始化的时候，也就是有一个bean的后置处理器进行执行。\nSpring会查找这个类class对象的每一个方法上面是否有@PostConstruct这个注解，如果有，直接invoke即可。\nAOP讲到这里，我们应该都知道AOP是在什么时候创建出来的吧，即初始化之后通过后置处理器弄出一个代理对象，加入单例池里面。那我们可以考虑一个情况：\n如果一个bean被代理了，里面的所有注入的bean还会有值吗？\n我们第一直觉肯定是有的吧，不然怎么使用依赖的bean方法。但是实际上，在代理对象产生后，所有bean都变成了null。根据bean的生命周期我们可以看出来，在AOP动态代理创建了之后，不会再有一个DI环节，所有依赖的bean都是null。\n那不是出问题了吗？那我们调用这个被代理的bean去打印一下里面依赖的bean，真的会是null吗？\n实际上又是有值的。那不是矛盾了么？到底是有还是没有？\n还真没有。那为什么打印的时候又有值？\n我们以CGLIB代理为例。我们知道它可以通过继承的方式去为我们生成非接口的动态代理。假如父类UserService里面有一个test方法，打印了依赖的bean OrderService，，这个代理对象就会这样：\npublic class 某某Proxy extends UserService&#123;        @Override    public void test()&#123;        执行我们定义的切面逻辑……        调用原生的test方法……    &#125;&#125;\n看到调用原生的test方法，我们第一反应就是super.test()。但问题是，你依然没有对这个OrderService去进行依赖注入，调用父类的test方法仍然是null。所以肯定要调用有注入对象的对象方法。\n哪里有注入好的对象？从始至终就只有一个吧，那就是Spring在AOP创建前的那个对象。那代理对象又是怎么调用的呢？\n保存这个对象就好了。代理对象里面有一个字段target，表明被代理的对象是哪个，也就是 Private UserService target。\n这下我们就知道了：\npublic class 某某Proxy extends UserService&#123;        Private UserService target;    @Override    public void test()&#123;        执行我们定义的切面逻辑……        target.test();    &#125;&#125;\n这样就可以正常工作了。\nSpring事务事务其实也是一个代理对象。Spring会为开启了事务的类生成代理，然后执行类似于AOP的逻辑，在执行的前后插入事务控制逻辑。\n那怎么控制整体的事务呢？Spring让一个方法下的所有数据库操作都处于一个事务中，并用try-catch去判断是否要回滚。\n为了让一个方法下的所有操作都处于一个事务，肯定要把事务自动提交关闭，但是如果是JDBC原生连接，这个是默认开启的。所以Spring统一管理了一个jdbcTemplate bean，并且连接在创建的时候把自动提交关闭了。\n\n  \n    \n      注意\n\n    \n    \n      如果你自己建立了一个jdbc连接，即使加上@Transactional，事务仍然失效。\n\n    \n  \n事务执行流程：\n开启事务 --&gt; 事务管理器新建一个数据库连接connection，并关闭自动提交 --&gt; 业务SQL（jdbc bean需要拿到数据库连接） --&gt; 判断是否提交/回滚 \n\n为什么内部调用导致事务传播失效？这个时候我们就可以来讨论一下为什么内部调用会导致SPring事务失效了。\n我们可以看一下这个：\n@Transactionalpublic void a()&#123;    业务SQL；    b();&#125;@Transactional(propagation = Propagation.NEVER)public void b()&#123;    业务SQL；&#125;\n我们配置了b这个方法当外部有事务存在时候，就抛异常。但是这个代码运行起来真的会抛异常吗？\n当然不会。因为已经Spring事务在b已经失效了。@Transactional(propagation &#x3D; Propagation.NEVER)相当于没有写。\n为什么呢？我们想想上面的AOP原理：当执行业务方法的时候，我们调用的是target里面的原生方法。那么在原生方法里面，调用b方法可以看作：\nthis.b();\nthis是什么？是没有被代理的对象target吧？那对于必须要代理增强的事务来说，这个b没有被代理处理，自然b的事务就没有用了，也就相当于白写。\n那怎么破局？自然就是要让代理去执行吧。我们不能让this去做，那我们就去得到一个proxy。从单例池里面直接注入当前target的代理对象，用这个注入的代理对象再去调用b就行了，实际上就是套娃。\npublic class userService&#123;    @Autowired    private UserService userService;     @Transactional    public void a()&#123;        业务SQL；        userService.b();    &#125;    @Transactional(propagation = Propagation.NEVER)    public void b()&#123;        业务SQL；    &#125;&#125;\n这样就可以在代理的target里面再套一个代理，就能使用了，这个时候运行就会抛出异常。\n@Configuration是怎么影响Spring事务的？在讲这个注解之前，回到最初的Spring事务准备流程。在正常使用事务功能前，是需要进行配置的。我们需要用bean声明连接，jdbc，数据源。其中，jdbc声明需要调用一次声明datasource bean的方法，连接声明也需要调用一次声明datasource bean的方法。\n配置好了之后，如果在配置类APPconfig里面，不加上@Configuration，我们试着去执行一下事务的方法，发现事务直接就不能用了，而且不是像上面一样传播的时候才失效，而是从一开始就直接坏了。\n为什么呢？在分析原理之前，我们要先知道一下Spring是通过什么去管理连接的。因为jdbc这个类对于每一个数据都是一样的，不一样的是不同数据的connection，jdbc只要拿到提前设置好的connection，就可以对每一个不同的数据库进行操作。\n又由于在处理一个方法的时候肯定是单线程执行的，所以这里Spring存储管理用的是ThreadLocal，里面的类型为Map&lt;DataSource, Connection&gt;。这样jdbc在每一条线程执行的时候，根据需要拿到不同数据库的连接了。\n那现在回到最初的bean声明环节。我们发现jdbc bean声明要调用一次DataSource bean声明方法，Connection bean声明也要调用一次DataSource bean声明方法。这样就会导致一个很大的问题：DataSource return了两个new的对象。换句话说，jdbc得到的DataSource对象和Connection得到的DataSource对象不一样，这个时候，当jdbc从ThreadLocal里面拿Connection，就会拿不到，那没办法了，Spring只得重新建立一个jdbc和connection去执行sql，但是此时，自动提交就是开启了的。事务当然也就失效了。\n要解决这个方法，加上@Configuration就行了。根据这个原理分析，我们很容易推断出@Configuration的解决方案是什么，也就是把jdbc和connection里面的DataSource进行一个统一，那他是怎么做的呢？\n同样基于动态代理。动态代理继承类，并重写声明连接，jdbc，数据源的bean方法。注意这里的重写方法里面调用的是super，而不是target。\n声明连接，jdbc没什么好做手脚的，问题主要出在数据源的bean声明。为了不让数据源bean声明两次，动态代理会在调用数据源的bean声明方法时候，先去单例池里面找有没有需要的DataSource的bean。如果有，就直接返回单例池里面的，只有没有才会进行创建。\n所以，@Configuration依照动态代理的方式，解决了这个问题。\n循环依赖问题见单独文章：循环依赖 —— 为什么是三级缓存？\n第三天的学习到这里也就结束了。\n","categories":["Spring"],"tags":["底层原理"]},{"title":"循环依赖——为什么是三级缓存？","url":"/2025/10/04/%E5%BE%AA%E7%8E%AF%E4%BE%9D%E8%B5%96%E2%80%94%E2%80%94%E4%B8%BA%E4%BB%80%E4%B9%88%E6%98%AF%E4%B8%89%E7%BA%A7%E7%BC%93%E5%AD%98%EF%BC%9F/","content":"针对循环依赖，应该我们都不陌生，就是beanA依赖于beanB，注入时候发现beanB里面又依赖beanA，导致双方都不能进行DI。那我们就来认真考虑并拆解一下Spring为什么使用了三级缓存来解决这个问题。\n首先我们自己先想一想这个问题应该要怎么解决。要破除循环，肯定某一方要先给出一个可以先注入的实例吧，这样才能让另一方去正常走完bean的生命周期，然后回头先给出的那一方就可以在单例池里面找到需要的成熟bean，也可以进行完整的bean生命周期了。\n我们可能会担心给出实例的一方还并未成熟，就注入到另一方去。没有关系，因为是引用传递，只要后面给出实例的一方也走完了生命周期，自然另一方里面的也就成熟了。\n那我们要在什么时候去给出一个暂时可以用来注入的实例呢？其实实例化完了之后就可以了，我们完全可以用一个Map去存储这个类型的一个暂时不成熟的bean，然后在DI另一方，碰到循环依赖的时候就把这个Map里面的暂不成熟bean先注入，就打破了循环。\n这样就万无一失了吗？这个方法只是打破了循环而已，还存在不少问题。其中最大的问题就是：如果这个暂不成熟的bean后续是要通过动态代理的，那另一方注入的岂不是变为原生实例，而不是动态代理的实例？\n为了解决这个问题，我们似乎要把AOP动态代理的创建提前一下，在用Map存储之前就创建动态代理，然后把代理对象放入Map，这样另一方拿到的就是代理对象了，也就是提前AOP。似乎这样就可以了，但是在实例化的时候，Spring还不能判断是否出现了循环依赖，得在DI的时候才会知道，所以AOP的提前不能提前到实例化之后马上进行。\n那好，那我们就先不用这个Map了，也就是先暂时不打破这个循环，我们得判断出是否出现了循环依赖。我们用一个CreationSet在bean生命周期的最开始保存有哪些bean还在生命周期中，在放入单例池后把他去掉。这样在DI注入的时候，另一方一查CreationSet，就知道有了循环依赖。这个时候，我们再创建AOP动态代理，把动态代理对象注入给另一方，似乎就可以了。\n那现在就有两个问题：\n1、我的AOP代理都创建好了，什么时候放入单例池里面呢？要知道，现在里面的被代理对象还是不成熟的，直接放进去会有很大的问题，那怎么办？\n2、我在创建AOP代理对象的时候，要怎么拿到原生对象？我们知道代理是要有原生的target的，用什么方法拿到呢？\n我们先再来考虑一个问题。如果A和B循环依赖；A和C也同时循环依赖，那么，在A和B之间注入的时候，A的动态代理被创建了一次（假设是A先执行DI）；但是，在A和C之间注入的时候，A的动态代理又被创建了一次，这就造成了代理对象不一致的问题。\n为了解决这个问题，我们考虑又用一个earlyMap，存储生成的代理对象，这样就可以保证唯一性。那我们有了这个Map，再回头看一下的那个放入单例池问题，我们就有思路了：在A原生实例生命周期执行完成，马上要加入单例池的时候，我把这个earlyMap里面的代理对象拿出来放入单例池，不就可以了吗？\n现在就剩下怎么拿到原生对象的问题了。我们发现，现在的做法还并没有打破循环，也就是原生对象还并没有提供方法让AOP创建的时候拿到。\n那就再来一个factoriesMap！我直接往里面丢实例化完了的对象不就好了吗？\n但是值得注意的是，Spring没有之间放一个实例化对象作为value。他是放了一个函数式接口也就是lambda表达式进去；当DI循环依赖需要动态代理的时候，从这个factoriesMap一取，就是这个lambda表达式。这个lambda表达式会决定是否执行动态代理的创建。\n现在，一个完美的循环依赖解决方案就出来了！现在我们分析一下这个解决方法对应于Spring里面的哪些内容：\n正在创建集合singletonsCurrentlyInCreation：保存有哪些bean还在生命周期中，对应讲到的CreationSet。\n三级缓存singletonFactories：实例化后，放入beanName作为键，lambda作为值的Map，对应讲到的factoriesMap。\n二级缓存earlySingletonObjects：存储生成的代理对象，避免在多个循环依赖中创建多个不同的代理对象，对应讲到的earlyMap。\n一级缓存singletonObjects：单例池。\n\n  \n    \n      注意\n\n    \n    \n      Spring本身并不关心循环不循环的问题。他只是想能否通过暴露早期对象，解决同时创建两个互相需要的bean的问题。\n\n    \n  \n完整流程：\nbeanA进入生命周期，标记为正在创建，进入singletonsCurrentlyInCreation集合。A被实例化，A的ObjectFactory放入三级缓存。进行DI，发现了依赖beanB。会先进入一级缓存查找是否有成熟beanB。没有的话，开始进行B的创建（getBean()），由于singletonsCurrentlyInCreation集合中没有B，不提前暴露早期对象。\nbeanB进入生命周期，和A一样的流程。在DI时，发现依赖A。Spring通过查询singletonsCurrentlyInCreation发现A也在创建，决定提前暴露早期对象。\n查询一级缓存单例池，发现没有，加锁读二三级缓存，如果支持循环依赖，就会在其中一个缓存读到A。取出，就是A的代理对象（如果需要动态代理增强）因为二级缓存之中就是经过三级缓存决定是否创建代理之后产生的对象，三级缓存就是lambda，决定是否创建代理对象。然后A在同步块中被同步放入二级缓存，删除三级缓存内容，避免错误。\nB打破了循环，有了出口。这样A也就可以走完他的生命周期，循环依赖解决。\n那有的问题就来了：在循环依赖中，我们做到了代理对象的生成，那后面的初始化之后，Spring是怎么知道不要再创建一次动态代理的呢？\n其实在循环依赖提前AOP的时候，Spring把他放入了一个earlyProxyReference的一个Map中。这样就知道哪些bean是提前AOP的了；在后面的初始化之后，一调用这个Map的remove方法，返回的就是这个bean对象，一作比对就知道已经提前AOP过了，就不再进行动态代理的创建。\n\n  \n    \n      注意\n\n    \n    \n      即使没有循环依赖，这个三级缓存依然会在正常流程中使用到，比如每一次实例化都会加入三级缓存。不过二级缓存就基本不会使用了，因为二级缓存暴露了早期的对象，平常正常生命周期是不需要暴露的。\n\n    \n  \n我们可以想想：为什么是三级缓存，两级缓存不行吗？\n如果bean无需AOP，自然也就不用这么多级缓存了；直接把实例化后的对象丢到二级缓存里面就行了，这样另一方拿到的也是正确的原生实例对象。\n但是问题就出在某些bean需要AOP代理创建！如果只有二级缓存，要么你拿到的就是原生的实例，而不是代理对象；要么就是直接创建代理对象，但是这就违反了生命周期原则。因为我们知道直接创建代理对象，会导致被代理的target没有进行依赖注入而不是成熟的bean。所以，只有在真正需要早期引用时才决定是否创建代理对象，否则就应该遵守正常的生命周期流程。\n到这里，循环依赖的本质和解决核心我们都了解了。\n那我们再来考虑一个东西：@Async注解。\n假设我有这么一段代码：\n@EnableAsyncpublic class Appconfig&#123;    某某逻辑……&#125;@Asyncpublic void test()&#123;    某某逻辑……&#125;\n并且这个test方法写在一个A类中，A类本身无需AOP创建动态代理，而且A类和B类构成了循环依赖。那我们现在考虑一下，Spring是否会正常解决循环依赖问题呢？\n在得出答案之前，我们需要知道一个前提：@Async不是基于AOP创建的动态代理。如@Transactional注解就是基于AOP创建的动态代理，但@Async不是。他是另一个bean的后置处理器进行的动态代理创建。\n那有了这个前提，答案也就很清晰了：Spring会直接报错，因为用循环依赖解决方案出现了问题。具体出现在哪里呢？\n刚才说到，@Async不是基于AOP创建的动态代理。那回头看看我们的循环依赖解决流程中，如果正常走下来，二级缓存应该放的是A的原生实例，并且已经赋值给了B。但是，当走到初始化后的逻辑，由于@Async的动态代理还没有创建，就需要创建一个不是基于AOP的动态代理。创建完后，Spring把这个创建出的动态代理对象和二级缓存里面的原生对象一比较，发现不一样，直接就报错了，因为已经出现了错误。\n这个时候只能请另一个老祖出山了：@Lazy。@Lazy又是一个不是基于AOP创建的动态代理，实际上，他也不是跟@Async一样bean后置处理器创建的动态代理。那这个@Lazy是怎么破除这个问题的呢？\n实际上，@Lazy不止能破除这个问题，他还能本质上解决循环依赖问题。我们再来看一个场景：\n假设某类A的构造函数注入的时候依赖的必须bean就已经和某类B形成了循环依赖，那岂不是连实例化都实例化不了？更何谈起三级缓存的早期对象存储，这个情况连Spring都无法解决。\n但是@Lazy老祖就可以。举个例子：\n@Lazypublic A(B b)&#123;    this.b = b;&#125;\n他的原理是：先把一个假的对象，实际上是一个他创建出的代理对象先塞到A里面的b中，这样A就有了出口，就可以正常创建bean。那什么时候把假的换成真的呢？当真正要使用到这个beanB的时候。这个时候去创建B的bean，也不会出现循环依赖，因为单例池里面已经有了A的bean。正如其名：@Lazy，也就是懒加载。\n好了，到这里，循环依赖的本质就被我们摸清了。\n我们还可以想想一个新问题：多例bean循环依赖问题能解决吗？\n当然不行啦，因为Spring不会去保存多例bean的早期对象。而且，如果两方允许创建，会直接导致死锁，因为多例Bean只有在被请求时才创建。\n那怎么办？多例bean就失去了循环依赖的解决方案吗？\n@Lazy老祖：又要我出山了吗？\n","categories":["Spring"],"tags":["底层原理"]},{"title":"手写Spring框架day4","url":"/2025/10/04/%E6%89%8B%E5%86%99Spring%E6%A1%86%E6%9E%B6day4/","content":"今天我们以Mybatis，一步步了解Spring和其他依赖的集成原理。\n在Spring中，集成Mybatis需要引入一个mybatis-spring的一个jar包。这个jar包会帮我们做好bean的注册等等。但我们今天就先不引入这个jar，只引入mybatis的原生依赖，我们试着自己实现两者的集成。\n现在代码如下：\n@Autowiredprivate UserMapper userMapper;public void test()&#123;    System.out.println(userMapper);&#125;\n显然会报错吧，因为没有useMapper这个bean。因为@Autowired默认require是true的。\n那我们就得考虑一下把这个bean放入IOC容器里面。但是我们知道，Mapper层都是接口对吧，所以如果我们是Mybatis，应该要为其去创建动态代理对象，再把动态代理对象放入IOC。\n那什么东西能为一个接口来生成动态代理呢？我们想到factoryBean，虽然@Bean也可以注册，但是对于mapper层，肯定不止一个接口吧，一个个注册就有问题了，再说，mybatis作为一个框架，是不知道你业务代码里面的具体mapper有多少，有什么，所以采用factoryBean是一个再合适不过的方法。\nFactoryBean具体详解可见单独文章：FactoryBean？BeanFactory？Spring中的那些有意思的内容\n那我们就建一个自己的SwissFactoryBean来继承FactoryBean吧。然后实现里面的getObject方法，为其生成一个动态代理返回就好了。然后再在下面的getObjectType里面声明一下userMapper.class，这样为UserMapper就注册了一个动态代理对象的bean。\n现在最开始的userMapper就能成功注入bean了。\n知道了这个，我们就可以尝试实现Mybatis和Spring的整合了。我们知道Mybatis里面有一个SqlSession，它可以为指定的接口生成动态代理。\nprivate SqlSession sqlSession;@Overridepublic Object getObject()&#123;    return sqlSession.getMapper(UserMapper.class);&#125;\n那么，这个SqlSession要怎么注入呢？我们可以通过SqlSessionFactory去得到：\n@Autowiredpublic void setSqlSession(SqlSessionFactory sqlSessionFactory)&#123;    this.sqlSession = sqlSessionFactory.openSession();&#125;\nSqlSessionFactory是可以通过我们的配置得到。我们可以通过xml文件配置内容，得到输入流；然后根据输入流创建出SqlSessionFactory，用@Bean交给Spring容器管理。\n那现在我们就可以用sqlSession来执行了吗，不，我们还得告诉MyBatis的全局配置里面有哪些mapper。\n@Autowiredpublic void setSqlSession(SqlSessionFactory sqlSessionFactory)&#123;    sqlSessionFactory.getConfiguration().addMapper(UserMapper.class);    this.sqlSession = sqlSessionFactory.openSession();&#125;\n现在我们就可以使用调用UserMapper层里面的方法，实现动态代理下的查询了。\n那又有新的问题了：我们目前的mapper类有哪些是写死的，如果的mapper有很多，总不能让使用者一个个去注册吧？并且每注册一个就得重新写一个类去实现FactoryBean，这种写死的方式肯定是不合理的。\n假设我们现在又有了一个OrderMapper，那我们就先开始尝试解耦合吧。先把SwissFactoryBean里面写死的地方提取出来，变成：\nprivate Class mapperClass;public SwissFactoryBean(Class mapperClass)&#123;    this.mapperClass = mapperClass;&#125;@Autowiredpublic void setSqlSession(SqlSessionFactory sqlSessionFactory)&#123;    sqlSessionFactory.getConfiguration().addMapper(mapperClass);    this.sqlSession = sqlSessionFactory.openSession();&#125;@Overridepublic Object getObject()&#123;    return sqlSession.getMapper(mapperClass);&#125;\n现在我们就可以通过构造函数去传入具体的类，然后对其进行动态代理bean的创建了。这样的话，我们就可以做到这样：\nAnnotationConfigApplicationContext applicationContext = new AnnotationConfigApplicationContext();applicationContext.register(AppConfig.class);AbstractBeanDefinition beanDefinition = BeanDefinitionBuilder.genericBeanDefinition().getBeanDefinition();beanDefinition.setBeanClass(SwissFactoryBean.class);beanDefinition.getConstructorArgumentValues().addGenericArgumentValue(UserMapper.class);applicationContext.registerBeanDefinition(&quot;userMapper&quot;, beanDefinition);applicationContext.refresh();\n通过容器去注册UserMapper的beanDefinition。我们只需要重复写这样的代码，对于我们的SwissFactoryBean，就可以创建多个mapper的代理了。这里面每一个bean的名字都是不重复的，所以不用担心看似多例的情况（如果有疑惑，可以看手写Spring框架Day3）。\n但是，这样看起来还是太乱了，有没有更优雅的方式呢？\n又一个扩展类来了：ImportBeanDefinitionRegistrar接口。至于这个接口具体是什么，和一些其他扩展类有什么关系，请看FactoryBean？BeanFactory？Spring中的那些有意思的内容。\n我们定义出自己的SwissImportBeanDefinitionRegistrar，实现ImportBeanDefinitionRegistrar接口及其方法：\n@Overridepublic void registerBeanDefinitions(AnnotationMetadata importingClassMetadata, BeanDefinitionRegistry registry)&#123;    AbstractBeanDefinition beanDefinition = BeanDefinitionBuilder.genericBeanDefinition().getBeanDefinition();    beanDefinition.setBeanClass(SwissFactoryBean.class);    beanDefinition.getConstructorArgumentValues().addGenericArgumentValue(UserMapper.class);    registry.registerBeanDefinition(&quot;userMapper&quot;, beanDefinition);    AbstractBeanDefinition beanDefinition1 = BeanDefinitionBuilder.genericBeanDefinition().getBeanDefinition();    beanDefinition1.setBeanClass(SwissFactoryBean.class);    beanDefinition1.getConstructorArgumentValues().addGenericArgumentValue(OrderMapper.class);    registry.registerBeanDefinition(&quot;orderMapper&quot;, beanDefinition1);&#125;\n这样我们就可以在这里面优雅的定义出所有的mapper，接下来只要让Spring知道这个类：\n@ComponentScan(...)@Import(SwissImportBeanDefinitionRegistrar.class)public class APPConfig&#123;    ...&#125;\n然后把原来main里面的模拟构造方法改回去，因为我们已经通过配置类引入了我们想要声明的mapper：\nAnnotationConfigApplicationContext applicationContext = new AnnotationConfigApplicationContext(APPConfig.class);\n通过@Import注解引入了这个ImportBeanDefinitionRegistrar，这样Spring就会知道我们的自定义的SwissImportBeanDefinitionRegistrar，帮我们通过我们定义的SwissFactoryBean去实现每一个mapper的动态代理了。\nOk，到这里，耦合就解开了，只要我们想，就可以方便的编码声明哪些mapper。\n接下来就是解决动态寻找mapper的问题了。我们会发现现在我们mapper有哪些仍然是写死的，只是解耦合，搭建好了方便的用一个FactoryBean去构造每个mapper动态代理的架构。那我们怎么实现动态的去识别有哪些mapper，然后自动的生成动态代理呢？\n很明显就是扫描吧。我们可以定义一个注解@SwissScan标记在APPConfig上面来指定扫描的包路径是什么。那既然这个注解标记在APPConfig上面了，那我们也就可以把@Import(SwissImportBeanDefinitionRegistrar.class)加到@SwissScan这个注解声明的上面，因为这是我们提供的一套，就没必要重复声明，都放在一起就好，并且他还提供了一个好处，那就是我们可以拿到@MapperScan里面用户定义的扫描路径。那现在我们就可以开始搭建扫描的逻辑了。\n在写死的SwissImportBeanDefinitionRegistrar下，我们开始定义：\n@Overridepublic void registerBeanDefinitions(AnnotationMetadata importingClassMetadata, BeanDefinitionRegistry registry, BeanNameGenerator importBeanNameGenerator) &#123;    Map&lt;String, Object&gt; annotationAttributes = importingClassMetadata.getAnnotationAttributes(SwissScan.class.getName());    String path = (String) annotationAttributes.get(&quot;value&quot;);        //下面是原先的逻辑    ...&#125;\n现在我们要进行包路径下的扫描了。我们完全可以借助Spring已经定义好的扫描器帮我们进行扫描，但是Spring定义好的扫描器只会扫描Bean对象，并不会扫描到接口。所以我们需要对扫描器进行一些改造。\n我们先定义一个自定义的扫描器SwissScanner，重写一些方法：（具体Spring底层扫描逻辑详见之后的手写Spring系列）\npublic class SwissScanner extends ClassPathBeanDefinitionScanner &#123;    public SwissScanner(BeanDefinitionRegistry registry) &#123;        super(registry);    &#125;    @Override    protected boolean isCandidateComponent(AnnotatedBeanDefinition beanDefinition) &#123;        //改变扫描对象：扫描接口        return beanDefinition.getMetadata().isInterface();    &#125;    @Override    protected Set&lt;BeanDefinitionHolder&gt; doScan(String... basePackages) &#123;        Set&lt;BeanDefinitionHolder&gt; beanDefinitionHolders = super.doScan(basePackages);        //注意：这里扫描出来的bean类型是原生的Mapper，如UserMapper，但是！接口是不能创建bean的，需要改为中介类型，也就是我们的FactoryBean类型去帮忙创建。        for (BeanDefinitionHolder beanDefinitionHolder : beanDefinitionHolders) &#123;            BeanDefinition beanDefinition = beanDefinitionHolder.getBeanDefinition();            //我们需要先往原生构造器里面放入原生的mapper类型，对应之前我们解耦合时候的private Class classMapper注入；            beanDefinition.getConstructorArgumentValues().addGenericArgumentValue(beanDefinition.getBeanClassName());            //然后我们再把原生mapper类型换为我们的FactoryBean类型SwissFactoryBean。            beanDefinition.setBeanClassName(SwissFactoryBean.class.getName());        &#125;        return beanDefinitionHolders;    &#125;&#125;\n这么一来，我们的特定扫描器就构建好了，并且在扫描的同时就已经帮我们把BeanDefinition注册好了。回到ImportBeanDefinitionRegistrar，直接删除原先的逻辑,执行扫描即可：\n@Overridepublic void registerBeanDefinitions(AnnotationMetadata importingClassMetadata, BeanDefinitionRegistry registry, BeanNameGenerator importBeanNameGenerator) &#123;    Map&lt;String, Object&gt; annotationAttributes = importingClassMetadata.getAnnotationAttributes(SwissScan.class.getName());    String path = (String) annotationAttributes.get(&quot;value&quot;);    SwissScanner swissScanner = new SwissScanner(registry);    swissScanner.addIncludeFilter(new TypeFilter() &#123;        @Override        public boolean match(MetadataReader metadataReader, MetadataReaderFactory metadataReaderFactory) throws IOException &#123;            return true;        &#125;    &#125;);    swissScanner.scan(path);&#125;\n为什么要添加addIncludeFilter详见之后的手写Spring系列。\n到这里，我们构建的集成框架就实现完毕了，这就是mybatis和spring集成的方法。\n","categories":["Spring"],"tags":["底层原理"]},{"title":"手写Spring框架day5","url":"/2025/10/05/%E6%89%8B%E5%86%99Spring%E6%A1%86%E6%9E%B6day5/","content":"今天我们了解一些Spring有关扫描深入的知识点。\nSpring扫描前的准备工作Spring的beanName生成在之前第一天的文章里面，我们聊到了一些beanName的生成原则，主要是类名首字母小写（如果第二字母没有大写），或者直接类名（第二字母大写），遵循驼峰命名规范。\n但是其实我们是可以自定义命名的规则的。\n@ComponentScan(value = &quot;com.swiss&quot;, nameGenerator = SwissBeanNameGenerator.class)public class AppConfig&#123;    ……&#125;public class SwissBeanNameGenerator implements BeanNameGenerator&#123;    @Override    public String generatorBeanName(BeanDefinition definition,BeanDefinitionRegistry registry)&#123;        //我们给原先的beanName拼上一个swiss前缀，生成我们特有的bean名字        return &quot;swiss&quot; + definition.getBeanClassName();    &#125;&#125;\n那如果我们没有定义呢？Spring在@Component中nameGenerator默认值是一个BeanNameGenerator.class。他会从注解中拿出nameGenerator，然后和BeanNameGenerator.class做比较，如果不等就是你有自己的beanName生成器，相等就使用默认的生成器。\n\n  \n    \n      注意\n\n    \n    \n      BeanNameGenerator.class是默认值，他只是一个接口，不是默认生成器！默认的生成器是一个AnnotationBeanNameGenerator的类，实现了BeanNameGenerator。\n\n    \n  \n那这个生成器内部是怎么实现的呢？他会去先判断你是否是通过@Component定义出来的bean；然后会去拿@Component里面value的属性，如果你有设置值，就直接使用；如果没有，先拿到beanClassName，然后处理成bean的类名；接着就是我们当时写的，根据Introspector.decapitalize(className)去生成bean的名字。\n这是里面的内部实现，Spring在扫描开始的时候，只是往扫描器里面放入了beanName的生成器，在扫描到beanDefinition的时候才会使用。\nScopeProxyMode的作用我们在定义一个bean的时候，我们有可能会指定一下这个bean需要在什么时候去创建。比如：\n@Component@Scope(WebApplicationContext.SCOPE_REQUEST)public class OrderService&#123;&#125;\n这样，我们这个OrderService的bean就只会在请求来的时候才会创建。但是如果我在其他地方非懒加载式的注入了这个bean，如果放任不管，肯定是会报错的吧。所以，Spring就提供了和@Lazy一样的方式，允许我们先放一个假的动态代理对象进去。\n那么这个动态代理是要用JDK还是CGLIB呢？我们就可以在@Scope里面去指定当前bean类需要使用哪种，或者在配置类的@ComponentScan里面统一配置，这就是ScopeProxyMode。如果没有指定的话，Spring就会默认不创建代理对象，就会产生问题。\n设置类路径下扫描组件匹配的资源文件模式Spring通过scanner.setResourcePattern(“…”)设置了在扫描包路径时，只加载符合该模式的class文件（或资源文件）。他的默认值是”**&#x2F;*.class”，也就是扫描指定包及其子包下所有的.class文件，然后对这些类进行注解检查。我们可以通过@ComponentScan去配置。\nExcludeFilterExcludeFilter，就是排除过滤器，用来排除bean的。比如你不想要某个类成为bean，你就可以配置把他排除，使得Spring不会有这个类的bean：\n@ComponentScan(value = &quot;com.swiss&quot;, excludeFilter = &#123;@Component.Filter(type = FilterType.ASSIGNABLE_TYPE,class = UserService.class),……&#125;)//数组形式public class AppConfig&#123;    ……&#125;\n其中，type指定你要根据什么去进行过滤，如ASSIGNABLE_TYPE就是直接指定类，后面的class就直接指定是哪个类；ANNOTATION就是指定一个注解，有标记这个注解的类就不会产生bean，后面的class指定是哪个注解类；ASPECTJ，指定切面表达式；REGEX，指定正则表达式等等。当你指定后，Spring就会把这个内容set到scanner里面。\n在扫描路径解析完毕后（下面会讲），Spring会自己添加一个排除的过滤器，排除的是什么呢？就是各种配置类，配置类是无需注册为bean的。\nlazyInit我们还可以在@Component里面指定你扫描的这个包是否全部都是懒加载的bean，相当于一个整体配置：\n@ComponentScan(value = &quot;com.swiss&quot;,lazyInit = true)\n这样Spring就会把这个内容set到scanner里面默认生成beanDefinition的策略，从非懒加载改为懒加载。\n扫描路径解析我们通常@Component里面会指定一个value，其实就是basePackages，如果我们使用这种方式标记扫描路径，就会自动解析出扫描的是指定的哪些包。\n但是如果我们不通过这个方式，还可以有别的方式。如basePackageClasses，我们可以指定类；Spring会解析出扫描的是这些类所在的包。\n如果我们都不指定呢？那Spring会直接根据你加了@Component的注解的类，也就是配置类的包来进行扫描。\n就像Spring boot，为什么我们加上@SpringbootApplication后，什么都没有指定，就会扫描这个启动类所在的所有包及其子包呢？就是因为这个注解里面有@Component注解，声明了这个启动类是一个配置类。\n开始进行扫描扫描的入口方法是doScan，在之前mybatis和Spring整合的时候应该我们都有见过。\n扫描是按照包的顺序进行的，也就是一个个for循环去扫描指定的包，然后生成一个个的set。\n去重Spring会对这些beanDefinition进行处理；前面的我们先不看，主要是处理一些特殊的注解如@DependsOn等等，我们看到处理的最后，Spring会做一件事：去重。有时候，包路径可能会产生包含的关系，可能一个bean就会被扫描到两次，这个时候就需要去重。只有确保没有重复，才会注册到容器中。\nSpring如果遇到重复的bean，还会检查是否兼容。如果不兼容，会直接抛出异常，容器初始化也就结束了。那什么是不兼容呢？\n不兼容就是指一个bean的名字却对应两个类型。比如，我的UserServicebean的名字是userService，但是如果我在OrderService里面的@Component里面再定义这个bean的名字是userService，就会出现bean的名字重复了，这个时候就是重大错误，需要直接抛出异常。\n否则就是兼容，但仍需要返回false说明这个bean已经重复了。\nfindCandidateComponents(String basePackage)中如何扫描 —— ASM技术我们有了路径，应该要如何去读取类的元数据呢？\n在之前我们手写Spring的时候，我们是利用的反射机制，去读取每一个类，然后获取有没有bean的声明注解，但是这在现在的Spring里面会导致一个问题：如果包下有很多很多类，难道要一个个都读入吗？我们知道JVM的策略永远是当类被使用的时候才会被加载，现在这样做不是直接违反了原则嘛。所以Spring就使用了自己封装的ASM技术，把类抽象化为资源，然后通过流式读取成一个资源元数据的reader，接着再执行判断。这样就不会产生加载过多类的问题了。\n这是最常见、最普通的做法。但是Spring不止使用这种最普通的方法，他还提供了一个优化的方法，也就是我们自己手动加索引，告诉Spring我有哪些bean。\n我们可以在META-INF包下建立一个Spring.components文件，里面声明所有我们的bean。但是注意：一旦你声明了，Spring就不会再去看其他的声明方式的内容了，比如你的@ComponentScan里面配置的路径失效了，Spring只会看这个文件的内容。所以这个是一个Spring提供的优化的方式。\n两重判断 —— 第一重 Exclude和Include现在我们拿到了类资源元数据的一个reader，我们就要开始判断这个类是否是一个bean了。\nSpring里面设定了两重判断，第一重就是ExcludeFilter和IncludeFilter判断。ExcludeFilter之前我们讲过，在scanner设置里面就已经set好了。那IncludeFilter是什么呢？\n其实，这个IncludeFilter是紧跟在ExcludeFilter后面设置好的。我们先来看看第一重判断的逻辑是什么，就知道IncludeFilter是什么用了：\n如果这个类被任何一个ExcludeFilter拦截，他就不可能是bean，返回false；如果这个类没有被任何一个ExcludeFilter拦截，他就有可能是一个bean，然后进行IncludeFilter拦截判断。如果一个类至少被一个IncludeFilter拦截，那他就有可能是一个bean，进行下一轮判断。如果一个类没有被一个IncludeFilter拦截，那他就不可能是一个bean，返回false。\n到这里，我们就应该知道了：IncludeFilter和ExcludeFilter相反，就是用来规定bean应该有哪些特质来进行拦截的。\n那Spring在当时set scanner的时候是怎么配置这个IncludeFilter的呢？\nSpring自己的一套IncludeFilter里面包含这些内容：**@Component，@ManagedBean，@Named**。只要有一个就行，但是后面两个基本用不到，所以基本上也就是扫描@Component的bean了。\n这两个条件判断通过后，就会进入下一轮判断。下一轮判断是判断我们@Condition注解定义的内容是否有符合，如：\n@Component@Condition(SwissCondition.class)某某类……public class SwissCondition implement Condition&#123;    @Override    public boolean matches(ConditionContext context,AnnotationTypeMetadata metadata)&#123;        //实现自己的条件    &#125;&#125;\n如果你的条件match失败，这个bean也就不能生成了，如果match成功，bean就可以进入下一重判断。\n第二重 —— 类的性质判断现在这个bean的第一重条件检验通过了，现在就是对这个类性质的判断：是否独立类，是否接口，是否抽象类，是否有lookup注解（下面会讲）。\n判断的逻辑是：如果你的类是独立类，并且不是抽象类和接口，或者你是抽象类，但是里面的方法有@Lookup注解，就可以是一个bean。\n那什么是独立类呢？\n不继承自其他类除Object；\n不作为非静态内部类（inner class）或嵌套类存在；（静态内部类是可以单独实例化的！）\n可以单独编译、实例化和使用；\n与其他类之间没有强耦合关系。\n好，那我们再看看什么是@Lookup注解。\nlookup注解本来是用来解决单例里面需要多例bean的需求。比如，一个单例bean注入了一个多例bean，但是在运行环境，我们再怎么运行这个多例bean都是一样的，因为被注入bean的是单例bean。这个lookup注解就有用了，他的功能是：加在方法上的时候，不执行这个方法，而是返回一个这个方法返回值类型的bean。其实返回的就是一个动态代理，但只要一直调用这个加上了lookup注解的方法，就可以实现单例bean得到多个不一样的多例bean了。\nSpring允许抽象类里面有这个注解的时候去创建bean。\n到这里，Spring手写部分就先告一段落了，如果后续有补充，将会写在后面。\n","categories":["Spring"],"tags":["底层原理"]},{"title":"FactoryBean？BeanFactory？Spring中的那些有意思的内容","url":"/2025/10/04/FactoryBean%EF%BC%9FBeanFactory%EF%BC%9FSpring%E4%B8%AD%E7%9A%84%E9%82%A3%E4%BA%9B%E6%9C%89%E6%84%8F%E6%80%9D%E7%9A%84%E5%86%85%E5%AE%B9/","content":"BeanFactory和FactoryBean傻傻分不清？BeanFactory是Spring框架的核心接口之一，它定义了Spring容器的基本行为，负责管理Bean的生命周期、配置元数据和依赖注入。BeanFactory的主要功能包括：\nBean的实例化和管理：BeanFactory负责创建、初始化和管理Bean的生命周期。它会根据配置文件中定义的Bean定义来创建Bean的实例。\n依赖注入：BeanFactory负责解决Bean之间的依赖关系，确保每个Bean都能获取它所依赖的其他Bean。\n配置元数据的管理：BeanFactory会读取和管理应用程序的配置元数据，通常以XML、注解或Java配置的方式定义Bean及其属性。\n延迟初始化：BeanFactory支持延迟初始化，即只有在需要时才创建Bean实例。\nAOP支持：BeanFactory支持面向切面编程（AOP），允许在Bean的生命周期中应用切面。\nBeanFactory是Spring IOC容器的基础，但它通常不会直接使用，而是通过其更高级的实现来使用，如ApplicationContext。\nFactoryBean是一个特殊的Bean，它是一个工厂类的接口，负责创建其他Bean的实例。FactoryBean的主要功能包括：\n自定义Bean的创建过程：FactoryBean允许您自定义Bean的创建逻辑。您可以编写一个实现FactoryBean接口的类，重写getObject方法，以自定义Bean的创建逻辑。\n懒加载：FactoryBean可以控制Bean的懒加载。如果您的FactoryBean返回一个代理对象，它可以推迟实际Bean的创建，直到被请求时。\nBean的包装：FactoryBean可以用于包装其他Bean。您可以在FactoryBean中创建一个Bean的代理，以便在Bean的生命周期中添加额外的行为。\n处理复杂逻辑：FactoryBean常用于创建复杂的Bean实例，例如连接池、远程服务代理等。它们允许您在Bean的创建过程中执行复杂的逻辑。\nBeanFactory 和 FactoryBean区别\n用途：BeanFactory是Spring IoC容器的核心接口，负责管理Bean的生命周期和依赖注入。FactoryBean是一个特殊的Bean，充当其他Bean的工厂，用于自定义Bean的创建过程。\n创建对象：BeanFactory负责创建Bean对象。FactoryBean是一个Bean，它的实例本身是一个工厂，负责创建其他Bean的实例。\n自定义性：BeanFactory通常不需要自定义实现，而是由Spring框架提供的。FactoryBean需要自定义实现，您需要编写一个类，实现FactoryBean接口，并重写getObject方法来定义Bean的创建逻辑。\n懒加载：BeanFactory默认支持懒加载，可以配置Bean的延迟初始化。FactoryBean可以通过返回代理对象来实现懒加载，它控制何时创建实际的Bean实例。\n简而言之，BeanFactory是Spring IoC容器的核心接口，负责管理Bean的生命周期和依赖注入，大多数的Bean对象，包括Spring中内置的Bean对象和应用程序自定义的Bean对象，都是由BeanFactory创建。而FactoryBean是一个特殊的Bean，它充当其他Bean的工厂，用于自定义Bean的创建过程，支持懒加载、包装和代理，以及处理复杂的逻辑。\nBean可以由两种不同的方式创建：\n由BeanFactory创建：大多数Bean是由Spring的BeanFactory或ApplicationContext容器直接创建的，这些Bean是普通的Java对象，不需要实现FactoryBean接口。当您在Spring配置中定义一个Bean时，通常是直接指定该Bean的类，并且Spring容器会根据类的信息来实例化和管理Bean的生命周期。这些Bean不需要实现FactoryBean接口。\n由FactoryBean创建：有些特殊类型的Bean是由实现了FactoryBean接口的类创建的。FactoryBean是一种用于创建其他Bean的工厂，它允许自定义Bean的创建过程。这些FactoryBean实现类实现了FactoryBean接口，重写了getObject方法，用于定义Bean的创建逻辑。\nBeanDefinitionRegistryPostProcessor是什么？BeanDefinitionRegistryPostProcessor是Spring框架中的一个扩展接口，用于在Spring容器加载bean定义（BeanDefinition）之后、但在所有常规的BeanFactoryPostProcessor执行之前，对bean定义注册表（BeanDefinitionRegistry）进行进一步的修改或注册额外的bean定义。\n接口定义如下：\npublic interface BeanDefinitionRegistryPostProcessor extends BeanFactoryPostProcessor &#123;    void postProcessBeanDefinitionRegistry(BeanDefinitionRegistry registry) throws BeansException;&#125;\n新增了一个方法postProcessBeanDefinitionRegistry(BeanDefinitionRegistry registry)，可以动态注册bean：\n@Componentpublic class MyBeanDefinitionRegistryPostProcessor implements BeanDefinitionRegistryPostProcessor &#123;    @Override    public void postProcessBeanDefinitionRegistry(BeanDefinitionRegistry registry) throws BeansException &#123;        // 动态注册一个bean        BeanDefinitionBuilder builder = BeanDefinitionBuilder.genericBeanDefinition(MyService.class);        AbstractBeanDefinition beanDefinition = builder.getBeanDefinition();        registry.registerBeanDefinition(&quot;myDynamicService&quot;, beanDefinition);        System.out.println(&quot;动态注册了bean: myDynamicService&quot;);    &#125;    @Override    public void postProcessBeanFactory(ConfigurableListableBeanFactory beanFactory) throws BeansException &#123;        // 可进行进一步处理        System.out.println(&quot;BeanFactory 后处理&quot;);    &#125;&#125;\nBeanFactoryPostProcessor又是什么？用于在Spring容器实例化任何bean之前，对bean的定义（BeanDefinition）进行修改或处理。\n@Componentpublic class MyBeanFactoryPostProcessor implements BeanFactoryPostProcessor &#123;    @Override    public void postProcessBeanFactory(ConfigurableListableBeanFactory beanFactory) throws BeansException &#123;        BeanDefinition bd = beanFactory.getBeanDefinition(&quot;userService&quot;);        bd.setLazyInit(true); // 设置为懒加载        bd.getPropertyValues().add(&quot;defaultRole&quot;, &quot;USER&quot;); // 添加默认属性    &#125;&#125;\nImportBeanDefinitionRegistrar是做什么工作的？ImportBeanDefinitionRegistrar主要用于在Spring容器启动过程中动态地向容器中注册Bean定义（BeanDefinition）。通常配合@Import注解一起使用。\n@Configuration@Import(MyImportBeanDefinitionRegistrar.class)public class AppConfig &#123;&#125;\n接口的定义是这样：\npublic interface ImportBeanDefinitionRegistrar &#123;    default void registerBeanDefinitions(            AnnotationMetadata importingClassMetadata,            BeanDefinitionRegistry registry) &#123;    &#125;    default void registerBeanDefinitions(            AnnotationMetadata importingClassMetadata,            BeanDefinitionRegistry registry,            BeanNameGenerator importBeanNameGenerator) &#123;        registerBeanDefinitions(importingClassMetadata, registry);    &#125;&#125;\nimportingClassMetadata：表示使用@Import的那个配置类的元数据（如类名、注解信息等）。\nregistry：用于注册BeanDefinition的注册表。\nBean是线程安全的吗？当然不是。如果这个bean中有成员变量，在读写的时候就会发生线程不安全的问题。\n解决方法也有很多，比如ThreadLocal，变量放入方法，多例bean，加锁等等。\nBeanDefinition的注册顺序由什么来决定？主要是由注解（配置）的解析顺序来决定：\n1、@Configuration2、@Component3、@Import：导入普通类4、@Bean5、@Import—导入的是实现了ImportBeanDefinitionRegistrar的类6、BeanDefinitionRegistryPostProcessor\nAOP在Spring内的具体实现是怎么样的？仅是动态代理吗Aop的实现大致分为三大步：\nJavaConfig当@EnableAspectJAutoProxy 会通过@Import注册一个BeanPostProcessor处理AOP\n解析切面：在Bean创建之前的第一个Bean后置处理器会去解析切面（解析切面中通知、切入点，一个通知就会解析成一个advisor(通知、切入点)）\n创建动态代理：正常的Bean初始化后调用BeanPostProcessor拿到之前缓存的advisor，再通过advisor中pointcut判断当前Bean是否被切入点表达式匹配，如果匹配，就会为Bean创建动态代理（创建方式1.jdk动态代理2.cglib）。\n调用：拿到动态代理对象，调用方法就会判断当前方法是否增强的方法，就会通过调用链的方式依次去执行通知。\nSpring AOP和AspectJ的AOP有什么区别？我们常常在我们想要使用Spring AOP的时候，会去引入一个依赖：AspectJ。这个包为什么要引入呢？\n实际上，AspectJ这个的代理和AOP代理不一样，他是属于静态代理，也就是编译时织入。这样一来，AspectJ的性能就会非常好，因为运行的时候就会没有额外开销。所以AspectJ是一种完全的AOP编程解决方案。\n但SpringAOP就不一样了，他不会去追求完整的解决方案；而是致力于企业级开发最普遍的需求。所以，SpringAOP仅仅只是使用到了AspectJ里面的切点切面表达式的解析和匹配，并生成动态代理。但也因为这样，Spring AOP的性能也会比较差一些。\n","categories":["Spring"],"tags":["底层原理"]},{"title":"Elasticsearch和kibana的docker部署","url":"/2025/10/07/Elasticsearch%E5%88%9D%E5%85%A5%E9%97%A8%E2%80%94%E2%80%94es%E5%92%8Ckibana%E7%9A%84%E9%83%A8%E7%BD%B2/","content":"","categories":["Elasticsearch"],"tags":["部署方法"]}]
[{"title":"SQL窗口函数的使用","url":"/2025/06/17/SQL%E7%AA%97%E5%8F%A3%E5%87%BD%E6%95%B0/","content":"这篇文章着重于理解数据库中使用窗口函数进行高级SQL语句的编写方法，并加以使用。\n窗口函数相较于普通SQL，有什么不同？简单来说，窗口函数有以下功能：\n1、同时具有分组和排序的功能\n2、不减少原表的行数\n\n  \n    \n      运用场景举例\n\n    \n    \n      排名问题：每个部门按业绩来排名\ntopN问题：找出每个部门排名前N的员工进行奖励\n复购分析：App内要分析复购用户有多少\n累计问题：医院要经常统计累计患者数\n\n    \n  \n这类在每组内排名场景使用普通SQL语句很复杂，不易实现，这个时候就需要窗口函数简化查询语句的编写。\n窗口函数的基本使用窗口函数的基本语法如下：\n&lt;窗口函数&gt; over (partition by &lt;用于分组的列名&gt; order by &lt;用于排序的列名&gt;)\n\n那么语法中的窗口函数都有哪些呢？\n窗口函数的位置，可以放以下两种函数：\n1、专用窗口函数，包括rank, dense_rank, row_number等专用窗口函数。\n2、聚合函数，如sum. avg, count, max, min等。\n因为窗口函数是对where或者group by子句处理后的结果进行操作，所以窗口函数原则上只能写在select子句中。\n专用窗口函数rank以一个班级表举例：\n想在每个班级内按成绩排名，得到下面的结果。\n\n得到上面结果的sql语句代码如下:\nselect *,   rank() over (partition by 班级                 order by 成绩 desc) as rankingfrom 班级表\npartition by用来对表分组,order by子句的功能是对分组后的结果进行排序。\n窗口函数具备了group by子句分组的功能和order by子句排序的功能。那么为什么还要用窗口函数呢？\n因为，group by分组汇总后改变了表的行数，一行只有一个类别。而partiition by和rank函数不会减少原表中的行数。\n其他专用窗口函数rank, dense_rank, row_number有什么区别呢？举个例子：\nselect *,   rank() over (order by 成绩 desc) as ranking,   dense_rank() over (order by 成绩 desc) as dese_rank,   row_number() over (order by 成绩 desc) as row_numfrom 班级表\n上述代码得到结果如图：\n\n从上面的结果可以看出：\n\n  \n    \n      专用函数区别\n\n    \n    \n      rank函数：这个例子中是5位，5位，5位，8位，也就是如果有并列名次的行，会占用下一名次的位置。比如正常排名是1，2，3，4，但是现在前3名是并列的名次，结果是：1，1，1，4。\ndense_rank函数：这个例子中是5位，5位，5位，6位，也就是如果有并列名次的行，不占用下一名次的位置。比如正常排名是1，2，3，4，但是现在前3名是并列的名次，结果是：1，1，1，2。\nrow_number函数：这个例子中是5位，6位，7位，8位，也就是不考虑并列名次的情况。比如前3名是并列的名次，排名是正常的1，2，3，4。\n\n    \n  \n\n可以用一张图解释：\n\n聚合函数作为窗口函数select *,   sum(成绩) over (order by 学号) as current_sum,   avg(成绩) over (order by 学号) as current_avg,   count(成绩) over (order by 学号) as current_count,   max(成绩) over (order by 学号) as current_max,   min(成绩) over (order by 学号) as current_minfrom 班级表\n看一下结果：\n如上图，聚合函数sum在窗口函数中，是对自身记录、及位于自身记录以上的数据进行求和的结果。比如0004号，在使用sum窗口函数后的结果，是对0001，0002，0003，0004号的成绩求和，若是0005号，则结果是0001号~0005号成绩的求和，以此类推。\n不仅是sum求和，平均、计数、最大最小值，也是同理，都是针对自身记录、以及自身记录之上的所有数据进行计算。\n这样使用窗口函数有什么用呢？聚合函数作为窗口函数，可以在每一行的数据里直观的看到，截止到本行数据，统计数据是多少（最大值、最小值等）。同时可以看出每一行数据，对整体统计数据的影响。\n注意：partition子句可是省略，省略就是不指定分组。但是，这就失去了窗口函数的功能，所以一般不这么使用。\n一个练习具体例子1.获取每个部门中薪水最高的员工相关信息\n参考答案 \n              \n              WITH mix AS (    SELECT d.dept_no, d.emp_no, s.salary    FROM dept_emp d    JOIN salaries s ON d.emp_no = s.emp_no),rank_table AS (    SELECT *,           RANK() OVER (PARTITION BY dept_no ORDER BY salary DESC) AS salary_rank    FROM mix)SELECT dept_no, emp_no, salaryFROM rank_tableWHERE salary_rank = 1;\n              \n            \n\n参考来源: 知乎：通俗易懂的学会SQL窗口函数\n","categories":["SQL"],"tags":["SQL编写"]},{"title":"手写Spring框架Day2","url":"/2025/10/02/%E6%89%8B%E5%86%99Spring%E6%A1%86%E6%9E%B6Day2/","content":"进入第二天了，今天要学的东西就比较深入一些了。\n第一部分 依赖注入在昨天我们已经实现了bean的创建和管理。既然创建了bean，那就需要使用，也就是当一个bean要使用到别的bean，就得把这个bean给他放入需要bean的类中吧。\n怎么实现呢？首先肯定想到怎么标识需要注入的地方，用过Spring的都知道有一个@Autowired注解。那我们就把他创建出来。\n@Retention(RetentionPolicy.RUNTIME)@Target(ElementType.FIELD)public @interface Autowired &#123;    String value() default &quot;&quot;;&#125;\n我们再创建一个新的OrderService，把他也注册成bean。然后，在原先的UserService中去注入这个OrderService的bean。\n@Componentpublic class OrderService &#123;&#125;@Componentpublic class UserService &#123;    @Autowired    private OrderService orderService;    public void  test()&#123;        System.out.println(orderService);    &#125;&#125;\n好了，现在标识已经做好了。那不能只有表面功夫吧，加个注解就完事；肯定要为他去实现一个依赖注入的功能。要在哪里实现呢？\n想想昨天写过的东西，构造函数？似乎只是用来扫描和把创建出来的bean加入单例池；getBean？更不对了，只是用来获取bean的，都不知道要注入到哪里……\n对了！createBean可太适合不过了！在昨天的代码里，这里面可是把每一个bean进行实例化的地方，那实例化之后，跟着把里面的内容一起给他放进去，不是妙哉？\n所以，我们先获取实例化的实例所有内部字段，再一个个遍历判断是否有加上注解，如果加上了@Autowired，那就进行注入就好了。\n那怎么注入呢？首先需要拿到注入的bean实例，getBean方法就有用了，把字段的名字传给getBean，这样就拿到了需要注入的一个实例，我们写好的getBean会帮我们解决单多例的问题。然后就可以通过反射把这个bean注入了。\nprivate Object createBean(String beanName, BeanDefinition beanDefinition) &#123;    Class clazz = beanDefinition.getType();    try &#123;        Object instance = clazz.getConstructor().newInstance();        //依赖注入        for (Field field : clazz.getDeclaredFields()) &#123;            if(field.isAnnotationPresent(Autowired.class))&#123;                //允许修改                field.setAccessible(true);                //将这个bean实例注入需要注入的实例里                field.set(instance,getBean(field.getName()));            &#125;        &#125;        return instance;    &#125; catch (InstantiationException e) &#123;        throw new RuntimeException(e);    &#125; catch (IllegalAccessException e) &#123;        throw new RuntimeException(e);    &#125; catch (InvocationTargetException e) &#123;        throw new RuntimeException(e);    &#125; catch (NoSuchMethodException e) &#123;        throw new RuntimeException(e);    &#125;&#125;\n这样我们就实现bean的DI了！用测试方法看看bean的打印情况：\npublic class Test &#123;    public static void main(String[] args) &#123;        SwissApplicationContext swissApplicationContext = new SwissApplicationContext(AppConfig.class);        UserService userService = (UserService) swissApplicationContext.getBean(&quot;userService&quot;);        userService.test();    &#125;&#125;\ncom.swiss.service.OrderService@6f94fa3e\n依赖注入就实现了。\n第二部分 Aware回调在有的时候，我们在bean实例化和依赖注入后，想要得到一些注册出的bean内容，比如我并不知道bean名字在Spring容器中的默认命名规则，但我想要知道当前这个bean在IOC中以什么名字存储，这个时候就需要一个回调，我们可以根据这个回调，拿到bean的一些有关信息，这就是Aware回调。\n这里我们模拟一个bean名字获取的回调，创建回调接口：\npublic interface BeanNameAware &#123;    void setBeanName(String beanName);&#125;\n然后我们就可以去实现这个接口，得到beanName。注意，这个回调函数是在Spring中自动被调用的，也就是Spring会自动把bean名字传进来。\n@Componentpublic class UserService implements BeanNameAware &#123;    @Autowired    private OrderService orderService;    private String beanName;    @Override    public void setBeanName(String beanName) &#123;        this.beanName = beanName;    &#125;    public void test()&#123;        System.out.println(orderService);    &#125;&#125;\n这样我们通过beanName的Aware回调，拿到了想要的bean的名字。\n当然实际上还有好多回调：BeanClassLoaderAware，BeanFactoryAware，ApplicationContextAware……但是都和这个原理相同。\n第三部分 初始化回调在bean处理好了之后，我们想要对其进行一些预先的操作，比如给一些东西赋值啊之类的，这个时候就是属于初始化的内容了。\nSpring为初始化回调提供了一个接口，和上面的Aware一样，我们需要自己去实现，然后进行自己想要的操作。注意，这里面你想做什么，Spring都不会管，也不会传来任何参数，完全是你自己的逻辑。\npublic interface InitializingBean &#123;    void afterPropertiesSet();&#125;@Componentpublic class UserService implements BeanNameAware, InitializingBean &#123;    @Autowired    private OrderService orderService;    private String beanName;    private String INeed;    @Override    public void setBeanName(String beanName) &#123;        this.beanName = beanName;    &#125;    @Override    public void afterPropertiesSet() &#123;        //很多很多想要在初始化执行的都可以写在这里        this.INeed =  &quot;Mika&quot;;    &#125;    public void  test()&#123;        System.out.println(orderService);    &#125;&#125;\n比如在这里，我为我的一个成员变量赋了一个值，我还可以输出，存储……干什么都可以。这就是初始化的回调作用。\n第四部分 BeanPostProcessor Bean的后置处理器为了更好、更灵活的管理bean对象，Spring还在初始化的前后提供了处理的方法。BeanPostProcessor接口就是用来让插入在初始化前后的一些想要执行的逻辑。\npublic interface BeanPostProcessor &#123;    void postProcessBeforeInitialization(String beanName, Object bean);    void postProcessAfterInitialization(String beanName, Object bean);&#125;\n这两个方法分别在初始化前、后调用。\n我们可以试着实现以下这两个方法：\n@Componentpublic class SwissBeanPostProcessor implements BeanPostProcessor &#123;    @Override    public void postProcessBeforeInitialization(String beanName, Object bean) &#123;        if(beanName.equals(&quot;userService&quot;))&#123;            System.out.println(&quot;1111&quot;);        &#125;    &#125;    @Override    public void postProcessAfterInitialization(String beanName, Object bean) &#123;        if(beanName.equals(&quot;userService&quot;))&#123;            System.out.println(&quot;2222&quot;);        &#125;    &#125;&#125;\n我们实现的逻辑是：bean的名字是userService的时候，在初始化前打印一个1111，在初始化后打印一个2222。\n这些调用在我们写好逻辑后，Spring会帮我们自动在初始化前后调用。那Spring是怎么知道有哪些后置处理器的？\n这个需要在Spring里面进行处理。在注册完所有BeanDefinition后，专门处理BeanPostProcessor的创建，使其被初始化成一个成熟的bean，然后加入List进行管理。\n在处理其他正常bean的时候，遇到BeanPostProcessor子类就跳过即可。\n\n  \n    \n      提示！\n\n    \n    \n      但是！这里为了简单方便，我们在构造函数里面扫描的时候就直接创建BeanPostProcessor实例！实际上不应该是这样,会导致这样创建出来的实例没有被DI，是个残缺的bean，所以下面这一段代码仅供参考。\n\n    \n  \nif (clazz.isAnnotationPresent(Component.class)) &#123;    //说明这是一个bean，开始创建beanDefinition对象    //先把BeanPostProcessor的实现子类存起来    if (BeanPostProcessor.class.isAssignableFrom(clazz)) &#123;    BeanPostProcessor instance = (BeanPostProcessor) clazz.newInstance();    beanPostProcessorList.add(instance);&#125;……\n然后，在初始化前后，遍历bean后置处理器的List，执行定义的方法即可。\nfor (BeanPostProcessor beanPostProcessor : beanPostProcessorList) &#123;    instance = beanPostProcessor.postProcessBeforeInitialization(beanName,instance);&#125;//初始化if (instance instanceof InitializingBean) &#123;    ((InitializingBean) instance).afterPropertiesSet();&#125;for (BeanPostProcessor beanPostProcessor : beanPostProcessorList) &#123;    instance = beanPostProcessor.postProcessAfterInitialization(beanName,instance);&#125;\n我们试着运行一下：\n1111Mika（afterPropertiesSet，初始化方法打印）2222\n确实是在初始化的前后插入了逻辑。\n这就是bean的后置处理器BeanPostProcessor。在Spring里面实现了很多BeanPostProcessor，如下面的AOP。当然我们也可以自己实现BeanPostProcessor，执行想要的逻辑。\n第五部分 AOP在上一个部分中，讲到了Bean的后置处理器，可以在Bean被初始化的前后执行一些逻辑。\n但我们知道，我们有时候可能对于某个bean需要增强，如AOP的切面。这个时候，我们就需要代理对象来实现增强的内容，而不是原生的bean实例。\n在Spring中，有一个AnnotationAwareAspectJAutoProxyCreator，会解析@Aspect里面的内容，根据匹配的切点表达式得到是哪个bean，然后进行动态代理创建，构造一个拦截器链，按顺序执行前置通知、目标方法、后置通知等等。但我们这里同样是一个模拟，简单的处理。\n首先我们需要把上一部分的postProcessBeforeInitialization和postProcessAfterInitialization返回值改为Object。因为需要返回一个代理对象了。\n然后在postProcessAfterInitialization里面，也就是初始化完成后，我们将进行动态代理的创建。这里为userService增强，创建一个JDK动态代理，首先需要创建一个interface（JDK只支持接口代理）：\npublic interface UserInterface &#123;    void test();&#125;\n然后我们让UserService去实现这个接口，就可以为UserService创建动态代理了。\n@Overridepublic Object postProcessAfterInitialization(String beanName, Object bean) &#123;    if (beanName.equals(&quot;userService&quot;)) &#123;        return Proxy.newProxyInstance(SwissApplicationContext.class.getClassLoader(), bean.getClass().getInterfaces(), new InvocationHandler() &#123;            @Override            public Object invoke(Object proxy, Method method, Object[] args) throws Throwable &#123;                System.out.println(&quot;切面逻辑&quot;);                return method.invoke(bean, args);            &#125;        &#125;);    &#125;    return bean;&#125;\n可以看到，这里userService的bean已经将变成代理对象返回。那我们尝试使用getBean得到的bean去进行原先的test方法：\n切面逻辑com.swiss.service.OrderService@355da254\n成功了！增强逻辑被实现了，也就是我们的AOP动态代理增强实现了。\n第二天的学习内容结束了！\n","categories":["Spring"],"tags":["底层原理"]},{"title":"手写Spring框架Day1","url":"/2025/10/01/%E6%89%8B%E5%86%99Spring%E6%A1%86%E6%9E%B6day1/","content":"开始探究Spring啦！先从最简单最原理的部分写起。\n第一步 创建Spring容器日常使用的有根据路径拿到配置的容器类（ClassPathXmlApplicationContext），也有根据java配置类拿到配置的容器类（AnnotationConfigApplicationContext）。今天手写的是根据配置的Spring容器。创建容器类SwissApplicationContext。里面先写上一个成员变量，也就是指定的配置类：\nprivate Class configClass;\n创建一个类用来当作配置类，命名为AppConfig。配置类嘛，肯定有个配置类的注解，标志一下扫描的路径，也就是@ComponentScan。写出这个注解，加到配置类的头上：\n@ComponentScan(&quot;com.swiss.service&quot;)public class AppConfig &#123;&#125;\n然后我们创建一个用来当作bean的类UserService。当然，要注册成bean，最简单的一个注解就是@Component了。同样创建出来加到UserService头上。这两个注解目前都只有一个默认的value属性，一个定义扫描路径，一个定义bean的名字。现在可以回到容器SwissApplicationContext上了。容器容器，肯定是要拿bean的嘛，所以肯定有一个getBean方法。所以创建一个暂时返回null的getBean，后续补充。\npublic Object getBean(String beanName) &#123;    return null;&#125;\n新建Test类，把容器new出来。\nSwissApplicationContext swissApplicationContext = new SwissApplicationContext(AppConfig.class);\n然后写一个getBean：\nUserService userService = (UserService) swissApplicationContext.getBean(&quot;userService&quot;);\n当然这个getBean只是一个暂时的。毕竟bean的类型还需要确定嘛。到这里，前置的Spring容器创建准备就做好了。\n第二步 开始扫描我们知道，在容器创建的时候，就要开始进行bean的创建了。那么第一步肯定是发现bean吧，所以肯定在构造函数里面开始进行扫描。这个时候就用到了配置类：配置类的顶着@ComponentScan注解，告诉Spring容器应该在哪里去扫描bean，就像上面写的一样：\n@ComponentScan(&quot;com.swiss.service&quot;)\n所以首先就得获得这个配置类告诉我们的包路径了。容器里面已经有一个配置类的成员变量实例了，直接拿来用：\nif (configClass.isAnnotationPresent(ComponentScan.class)) &#123;&#125;\n存在ComponentScan注解，再获取扫描包路径：\nComponentScan componentScanAnnotation = (ComponentScan) configClass.getAnnotation(ComponentScan.class);String path = componentScanAnnotation.value(); //获得扫描路径 com.swiss.service\n但是现在就有一个问题了：扫描的内容应该是编译出来的class文件，因为运行时环境只加载.class文件，并且Spring依赖Java反射机制，所以这个路径需要做一些处理才能得到真正的编译出class文件的路径。\nstep1：把路径里面的”.”改为”&#x2F;“。path = path.replace(&quot;.&quot;, &quot;/&quot;);//com/swiss/service\nstep2：（最重要）通过类加载器得到class资源存放路径，因为JVM会通过类路径（classpath）来查找.class文件和资源文件。ClassLoader classLoader = SwissApplicationContext.class.getClassLoader();URL resource = classLoader.getResource(path);\n如果路径中有空格等非全英文路径情况，记得URL解析一下：\nString decodedPath;try &#123;    decodedPath = URLDecoder.decode(resource.getFile(), String.valueOf(StandardCharsets.UTF_8));&#125; catch (UnsupportedEncodingException e) &#123;    System.out.println(&quot;URL错误！&quot;);    return;&#125;\n如果没有的话，直接File file &#x3D; new File(resource.getFile());即可，否则传入解析后的URL。这个时候存放class文件的File文件夹就被我们获取到了。我们可以遍历文件，判断哪些是.class文件，然后进一步处理。\nif (file.isDirectory()) &#123;    File[] list = file.listFiles();    for (File f : list) &#123;        String fileName = f.getAbsolutePath();        if (fileName.endsWith(&quot;.class&quot;)) &#123;                                &#125;    &#125;&#125;\n接着，如果是class文件，要怎么办呢？就得开始确定这个类是否为bean了吧。我们知道，bean是通过@Component注解指定的，所以我们只需要确定类上有没有这个注解。那又怎么拿到这个class对象呢？找找前面，我们发现有一个classloader已经被我们定义好了。那直接把这个类的全限定名丢进去load，不就得到这个class对象了吗？这个时候，我们就可以判断是否有注解声明啦。\ntry &#123;    //这边需要传入一个类的全限定名字，如com.swiss.service.UserService，这边为了省事，就写死，实际上应该要去完成一个灵活的路径拆分得到全限定名字    String className = fileName.substring(fileName.indexOf(&quot;com&quot;), fileName.indexOf(&quot;.class&quot;));    className = className.replace(&quot;\\\\&quot;, &quot;.&quot;);    System.out.println(className);    Class&lt;?&gt; clazz = classLoader.loadClass(className);    if (clazz.isAnnotationPresent(Component.class)) &#123;        //说明这是一个bean    &#125;&#125; catch (ClassNotFoundException e) &#123;    System.out.println(&quot;获取是否为bean时，加载类失败！&quot;);    return;&#125;\n扫描的原理也就到这里结束咯。\n第三步 BeanDefinition的生成在上一步中，我们判断到了某一个类是否为一个bean，那么接下来是不是应该要开始创建实例存储了呢？当然不急！虽然还没写之前还有所耳闻，Spring里面是单例bean；但是bean也是可以多例的。为了标识这个bean是否需要多例，需要一个@Scope注解。\n@Target(ElementType.TYPE)@Retention(RetentionPolicy.RUNTIME)public @interface Scope &#123;    String value() default &quot;&quot;;&#125;\n对于之前的UserService，我们加上这个注解：\n@Component@Scope(&quot;prototype&quot;)public class UserService &#123;&#125;\nprototype应该不陌生吧，就是多例。标记好了bean的单多例情况，接下来难道就要开始创建了吗？也不是，Spring在真正实例化bean的前面还加了一个态：BeanDefinition，方便处理单多例情况。那我们就着手写一个beanDefinition吧。也就是bean的定义。需要一些什么成员变量呢？首先肯定是类型。class类型对象，然后就是scope，也就是单多例情况。先写这两个吧。\npublic class BeanDefinition &#123;    private Class type;    private String scope;    public Class getType() &#123;        return type;    &#125;    public void setType(Class type) &#123;        this.type = type;    &#125;    public String getScope() &#123;        return scope;    &#125;    public void setScope(String scope) &#123;        this.scope = scope;    &#125;&#125;\n这下我们就可以回头继续完成构造方法了，当判断到一个类是bean的时候，我们先对其进行定义，通过解析@Scope确定单多例和@Component确定bean的名字（如果没有，默认使用类名）：\nString beanName = clazz.getAnnotation(Component.class).value();if (beanName.isEmpty()) &#123; //这边需要判断用户是否有指定bean名字，如果没有就应该使用默认规定变为驼峰，或者不变，如URLService就无需变化    beanName = Introspector.decapitalize(clazz.getSimpleName());&#125;BeanDefinition beanDefinition = new BeanDefinition();if (clazz.isAnnotationPresent(Scope.class)) &#123;    Scope scopeAnnotation = clazz.getAnnotation(Scope.class);    beanDefinition.setScope(scopeAnnotation.value());&#125; else &#123;    beanDefinition.setScope(&quot;singleton&quot;);&#125;beanDefinition.setType(clazz);\n构建好了，把这个定义存起来就行了。在容器里面新定义一个线程安全哈希表，并加入：\nprivate ConcurrentHashMap&lt;String, BeanDefinition&gt; beanDefinitionMap = new ConcurrentHashMap&lt;&gt;();beanDefinitionMap.put(beanName, beanDefinition);\n好了，beanDefinition的定义就构建出来了。\n第四步 完成getBean方法我们现在已经有了一个存着beanDefinition的Map了，我们会发现有一些bean已经是单例的，那我们是不是可以考虑直接进行创建进行管理呢？完全可以！继续在构造函数后面进行添加一些创建的内容。注意：这一步我们并没有具体实现创建bean的流程，而是实现getBean的自身逻辑。对于单例的bean，我们可以创建一个单例池来进行管理，然后我们直接在构造函数最后开始进行创建单例bean：\nprivate ConcurrentHashMap&lt;String, Object&gt; singletonObjects = new ConcurrentHashMap&lt;&gt;();for (String beanName : beanDefinitionMap.keySet()) &#123;    BeanDefinition beanDefinition = beanDefinitionMap.get(beanName);    if (beanDefinition.getScope().equals(&quot;singleton&quot;)) &#123;        Object bean = createBean(beanName, beanDefinition);//createBean方法将在后面进行完成        singletonObjects.put(beanName, bean);    &#125;&#125;\n这么一来，我们直接就有了单例的bean池。那getBean也就好说了：\npublic Object getBean(String beanName) &#123;    BeanDefinition beanDefinition = beanDefinitionMap.get(beanName);    if (beanDefinition == null) &#123;        throw new NullPointerException();    &#125; else &#123;        String scope = beanDefinition.getScope();        if (scope.equals(&quot;singleton&quot;)) &#123;            Object bean = singletonObjects.get(beanName);            if (bean == null) &#123;                bean = createBean(beanName, beanDefinition);                singletonObjects.put(beanName, bean);            &#125;            return bean;        &#125; else &#123;            //多例            return createBean(beanName,beanDefinition);        &#125;    &#125;&#125;\ngetBean就是如此简单！\n第五步 创建bean终于来到创建Bean的时候了。在上面遗留的createBean方法中，我们可以用反射轻松的实现实例化一个bean：\nprivate Object createBean(String beanName, BeanDefinition beanDefinition) &#123;    Class clazz = beanDefinition.getType();    try &#123;        Object instance = clazz.getConstructor().newInstance();        return instance;    &#125; catch (InstantiationException e) &#123;        throw new RuntimeException(e);    &#125; catch (IllegalAccessException e) &#123;        throw new RuntimeException(e);    &#125; catch (InvocationTargetException e) &#123;        throw new RuntimeException(e);    &#125; catch (NoSuchMethodException e) &#123;        throw new RuntimeException(e);    &#125;&#125;\n那么似乎到目前为之，一个可以使用的核心架构就出来了呢。在Test方法里面，我们开始测试：\npublic class Test &#123;    public static void main(String[] args) &#123;        SwissApplicationContext swissApplicationContext = new SwissApplicationContext(AppConfig.class);        System.out.println(swissApplicationContext.getBean(&quot;userService&quot;));        System.out.println(swissApplicationContext.getBean(&quot;userService&quot;));        System.out.println(swissApplicationContext.getBean(&quot;userService&quot;));        System.out.println(swissApplicationContext.getBean(&quot;userService&quot;));    &#125;&#125;    \n看输出结果：\ncom.swiss.service.UserService@60e53b93com.swiss.service.UserService@60e53b93com.swiss.service.UserService@60e53b93com.swiss.service.UserService@60e53b93\n果然是单例！那再把Scope换成prototype呢：\ncom.swiss.service.UserService@5e2de80ccom.swiss.service.UserService@1d44bcfacom.swiss.service.UserService@266474c2com.swiss.service.UserService@6f94fa3e\n是多例，成功了。 \n到这里，第一天的核心的内容也就结束了。\n","categories":["Spring"],"tags":["底层原理"]}]